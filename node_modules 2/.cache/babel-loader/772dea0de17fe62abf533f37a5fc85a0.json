{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { convenient } from './gradation';\n/**\r\n * Takes seconds `elapsed` and measures them against\r\n * `gradation` to return the suitable `gradation` step.\r\n *\r\n * @param {number} elapsed - Time interval (in seconds). Is < 0 for past dates and > 0 for future dates.\r\n *\r\n * @param {string[]} units - A list of allowed time units\r\n *                           (e.g. ['second', 'minute', 'hour', …])\r\n *\r\n * @param {Object} [gradation] - Time scale gradation steps.\r\n *\r\n *                               E.g.:\r\n *                               [\r\n *                                 { unit: 'second', factor: 1 },\r\n *                                 { unit: 'minute', factor: 60, threshold: 60 },\r\n *                                 { format(), threshold: 24 * 60 * 60 },\r\n *                                 …\r\n *                               ]\r\n *\r\n * @return {?Object} `gradation` step.\r\n */\n\nexport default function grade(elapsed, now, units) {\n  var gradation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : convenient; // Leave only allowed time measurement units.\n  // E.g. omit \"quarter\" unit.\n\n  gradation = getAllowedSteps(gradation, units); // If no steps of gradation fit the conditions\n  // then return nothing.\n\n  if (gradation.length === 0) {\n    return;\n  } // Find the most appropriate gradation step\n\n\n  var i = findGradationStep(elapsed, now, gradation);\n  var step = gradation[i]; // If time elapsed is too small and even\n  // the first gradation step doesn't suit it\n  // then return nothing.\n\n  if (i === -1) {\n    return;\n  } // Apply granularity to the time amount\n  // (and fall back to the previous step\n  //  if the first level of granularity\n  //  isn't met by this amount)\n\n\n  if (step.granularity) {\n    // Recalculate the elapsed time amount based on granularity\n    var amount = Math.round(Math.abs(elapsed) / step.factor / step.granularity) * step.granularity; // If the granularity for this step\n    // is too high, then fallback\n    // to the previous step of gradation.\n    // (if there is any previous step of gradation)\n\n    if (amount === 0 && i > 0) {\n      return gradation[i - 1];\n    }\n  }\n\n  return step;\n}\n/**\r\n * Gets threshold for moving from `fromStep` to `next_step`.\r\n * @param  {Object} fromStep - From step.\r\n * @param  {Object} next_step - To step.\r\n * @param  {number} now - The current timestamp.\r\n * @param  {boolean} future - Is `true` for future dates (\"in 5 minutes\").\r\n * @return {number}\r\n * @throws Will throw if no threshold is found.\r\n */\n\nfunction getThreshold(fromStep, toStep, now, future) {\n  var threshold; // Allows custom thresholds when moving\n  // from a specific step to a specific step.\n\n  if (fromStep && (fromStep.id || fromStep.unit)) {\n    threshold = toStep[\"threshold_for_\".concat(fromStep.id || fromStep.unit)];\n  } // If no custom threshold is set for this transition\n  // then use the usual threshold for the next step.\n\n\n  if (threshold === undefined) {\n    threshold = toStep.threshold;\n  } // Convert threshold to a number.\n\n\n  if (typeof threshold === 'function') {\n    threshold = threshold(now, future);\n  } // Throw if no threshold is found.\n\n\n  if (fromStep && typeof threshold !== 'number') {\n    // Babel transforms `typeof` into some \"branches\"\n    // so istanbul will show this as \"branch not covered\".\n\n    /* istanbul ignore next */\n    var type = _typeof(threshold);\n\n    throw new Error(\"Each step of a gradation must have a threshold defined except for the first one. Got \\\"\".concat(threshold, \"\\\", \").concat(type, \". Step: \").concat(JSON.stringify(toStep)));\n  }\n\n  return threshold;\n}\n/**\r\n * @param  {number} elapsed - Time elapsed (in seconds).\r\n * @param  {number} now - Current timestamp.\r\n * @param  {Object} gradation - Gradation.\r\n * @param  {number} i - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\n\n\nfunction findGradationStep(elapsed, now, gradation) {\n  var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // If the threshold for moving from previous step\n  // to this step is too high then return the previous step.\n\n  if (Math.abs(elapsed) < getThreshold(gradation[i - 1], gradation[i], now, elapsed < 0)) {\n    return i - 1;\n  } // If it's the last step of gradation then return it.\n\n\n  if (i === gradation.length - 1) {\n    return i;\n  } // Move to the next step.\n\n\n  return findGradationStep(elapsed, now, gradation, i + 1);\n}\n/**\r\n * Leaves only allowed gradation steps.\r\n * @param  {Object[]} gradation\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\n\n\nfunction getAllowedSteps(gradation, units) {\n  return gradation.filter(function (_ref) {\n    var unit = _ref.unit; // If this step has a `unit` defined\n    // then this `unit` must be in the list of `units` allowed.\n\n    if (unit) {\n      return units.indexOf(unit) >= 0;\n    } // A gradation step is not required to specify a `unit`.\n    // E.g. for Twitter gradation it specifies `format()` instead.\n\n\n    return true;\n  });\n}","map":{"version":3,"sources":["../source/grade.js"],"names":["gradation","convenient","getAllowedSteps","i","findGradationStep","step","amount","Math","fromStep","threshold","toStep","type","JSON","getThreshold","elapsed","unit","units"],"mappings":"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","sourcesContent":["import { convenient } from './gradation'\r\n\r\n/**\r\n * Takes seconds `elapsed` and measures them against\r\n * `gradation` to return the suitable `gradation` step.\r\n *\r\n * @param {number} elapsed - Time interval (in seconds). Is < 0 for past dates and > 0 for future dates.\r\n *\r\n * @param {string[]} units - A list of allowed time units\r\n *                           (e.g. ['second', 'minute', 'hour', …])\r\n *\r\n * @param {Object} [gradation] - Time scale gradation steps.\r\n *\r\n *                               E.g.:\r\n *                               [\r\n *                                 { unit: 'second', factor: 1 },\r\n *                                 { unit: 'minute', factor: 60, threshold: 60 },\r\n *                                 { format(), threshold: 24 * 60 * 60 },\r\n *                                 …\r\n *                               ]\r\n *\r\n * @return {?Object} `gradation` step.\r\n */\r\nexport default function grade(elapsed, now, units, gradation = convenient)\r\n{\r\n\t// Leave only allowed time measurement units.\r\n\t// E.g. omit \"quarter\" unit.\r\n\tgradation = getAllowedSteps(gradation, units)\r\n\r\n\t// If no steps of gradation fit the conditions\r\n\t// then return nothing.\r\n\tif (gradation.length === 0) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Find the most appropriate gradation step\r\n\tconst i = findGradationStep(elapsed, now, gradation)\r\n\tconst step = gradation[i]\r\n\r\n\t// If time elapsed is too small and even\r\n\t// the first gradation step doesn't suit it\r\n\t// then return nothing.\r\n\tif (i === -1) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Apply granularity to the time amount\r\n\t// (and fall back to the previous step\r\n\t//  if the first level of granularity\r\n\t//  isn't met by this amount)\r\n\tif (step.granularity) {\r\n\t\t// Recalculate the elapsed time amount based on granularity\r\n\t\tconst amount = Math.round((Math.abs(elapsed) / step.factor) / step.granularity) * step.granularity\r\n\t\t// If the granularity for this step\r\n\t\t// is too high, then fallback\r\n\t\t// to the previous step of gradation.\r\n\t\t// (if there is any previous step of gradation)\r\n\t\tif (amount === 0 && i > 0) {\r\n\t\t\treturn gradation[i - 1]\r\n\t\t}\r\n\t}\r\n\r\n\treturn step\r\n}\r\n\r\n/**\r\n * Gets threshold for moving from `fromStep` to `next_step`.\r\n * @param  {Object} fromStep - From step.\r\n * @param  {Object} next_step - To step.\r\n * @param  {number} now - The current timestamp.\r\n * @param  {boolean} future - Is `true` for future dates (\"in 5 minutes\").\r\n * @return {number}\r\n * @throws Will throw if no threshold is found.\r\n */\r\nfunction getThreshold(fromStep, toStep, now, future)\r\n{\r\n\tlet threshold\r\n\r\n\t// Allows custom thresholds when moving\r\n\t// from a specific step to a specific step.\r\n\tif (fromStep && (fromStep.id || fromStep.unit)) {\r\n\t\tthreshold = toStep[`threshold_for_${fromStep.id || fromStep.unit}`]\r\n\t}\r\n\r\n\t// If no custom threshold is set for this transition\r\n\t// then use the usual threshold for the next step.\r\n\tif (threshold === undefined) {\r\n\t\tthreshold = toStep.threshold\r\n\t}\r\n\r\n\t// Convert threshold to a number.\r\n\tif (typeof threshold === 'function') {\r\n\t\tthreshold = threshold(now, future)\r\n\t}\r\n\r\n\t// Throw if no threshold is found.\r\n\tif (fromStep && typeof threshold !== 'number') {\r\n\t\t// Babel transforms `typeof` into some \"branches\"\r\n\t\t// so istanbul will show this as \"branch not covered\".\r\n\t\t/* istanbul ignore next */\r\n\t\tconst type = typeof threshold\r\n\t\tthrow new Error(`Each step of a gradation must have a threshold defined except for the first one. Got \"${threshold}\", ${type}. Step: ${JSON.stringify(toStep)}`)\r\n\t}\r\n\r\n\treturn threshold\r\n}\r\n\r\n/**\r\n * @param  {number} elapsed - Time elapsed (in seconds).\r\n * @param  {number} now - Current timestamp.\r\n * @param  {Object} gradation - Gradation.\r\n * @param  {number} i - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\r\nfunction findGradationStep(elapsed, now, gradation, i = 0)\r\n{\r\n\t// If the threshold for moving from previous step\r\n\t// to this step is too high then return the previous step.\r\n\tif (Math.abs(elapsed) < getThreshold(gradation[i - 1], gradation[i], now, elapsed < 0)) {\r\n\t\treturn i - 1\r\n\t}\r\n\t// If it's the last step of gradation then return it.\r\n\tif (i === gradation.length - 1) {\r\n\t\treturn i\r\n\t}\r\n\t// Move to the next step.\r\n\treturn findGradationStep(elapsed, now, gradation, i + 1)\r\n}\r\n\r\n/**\r\n * Leaves only allowed gradation steps.\r\n * @param  {Object[]} gradation\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\r\nfunction getAllowedSteps(gradation, units)\r\n{\r\n\treturn gradation.filter(({ unit }) => {\r\n\t\t// If this step has a `unit` defined\r\n\t\t// then this `unit` must be in the list of `units` allowed.\r\n\t\tif (unit) {\r\n\t\t\treturn units.indexOf(unit) >= 0\r\n\t\t}\r\n\t\t// A gradation step is not required to specify a `unit`.\r\n\t\t// E.g. for Twitter gradation it specifies `format()` instead.\r\n\t\treturn true\r\n\t})\r\n}"]},"metadata":{},"sourceType":"module"}