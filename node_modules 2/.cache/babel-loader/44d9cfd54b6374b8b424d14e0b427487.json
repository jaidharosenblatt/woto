{"ast":null,"code":"import API from \"../../../api/API\";\nimport { fetchSession } from \"./fetches\";\nimport { startLoading, stopLoading, clearError, setServerError, setSuccessMessage, setError, setCustomServerError } from \"../../status/actionCreators\";\nimport { updateCourse } from \"../../sorted-courses/actionCreators\";\nimport { editProfile } from \"../../auth/actionCreators\";\nimport selectors from \"../../selectors\";\nimport { clearSession, setSession } from \"./actionCreators\";\n/**\n * Opens a new session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} session - session object with start and end time\n * @param {*} meetingURL\n */\n\nexport const openSession = session => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n  const course = selectors.getCourse(getState());\n  const {\n    meetingURL\n  } = session;\n\n  try {\n    await API.openSession(courseID, session);\n\n    if (meetingURL) {\n      await dispatch(editProfile({\n        meetingURL\n      }, false));\n    } // set active session\n    // @TODO temporary refetch whole session since openSession returns different session object\n    // dispatch(actionCreators.setSession(courseID, newSession));\n\n\n    const courseWithSession = { ...course,\n      activeSession: true\n    };\n    await dispatch(fetchSession());\n    dispatch(updateCourse(courseWithSession));\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Closes an active session for the given courseID\n * @param {*} courseID\n * @param {*} userID\n */\n\nexport const closeSession = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n  const course = selectors.getCourse(getState());\n\n  try {\n    await API.closeSession(courseID);\n    dispatch(clearSession(courseID)); // update sorted courses\n\n    const courseWithNoSession = { ...course,\n      activeSession: false\n    };\n    dispatch(updateCourse(courseWithNoSession));\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"closing this session\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Join a session as a staffer\n * @param {*} courseID\n * @param {*} userID\n */\n\nexport const joinSession = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n\n  try {\n    await API.joinSessionAsStaffer(courseID); // await dispatch(actionCreators.setSession(courseID, session));\n    // @TODO temporary refetch whole session since openSession returns different session object\n\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Leave the session as a staffer (does not close the session)\n * @param {*} courseID\n * @param {*} userID\n */\n\nexport const leaveSession = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n\n  try {\n    await API.leaveSessionAsStaffer(courseID);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"leaving this session\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Edit the active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} changes\n * @param {*} meetingURL\n */\n\nexport const editSession = (changes, meetingURL) => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  dispatch(startLoading());\n\n  try {\n    if (meetingURL) {\n      await dispatch(editProfile({\n        meetingURL\n      }, false));\n    }\n\n    const session = await API.editSession(courseID, changes);\n    dispatch(setSession(courseID, session));\n    dispatch(clearError());\n    dispatch(setSuccessMessage(\"Edited session\"));\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Make an announcement in an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} userName - user's name\n * @param {*} message\n */\n\nexport const makeAnnouncement = (message, meetingURL) => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  const user = selectors.getUser(getState());\n  dispatch(startLoading());\n\n  try {\n    await API.makeAnnouncement(courseID, message, user.name, meetingURL);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"making this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Pin an announcement in an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} announcementID\n */\n\nexport const pinAnnouncement = announcementID => async dispatch => {\n  dispatch(startLoading());\n\n  try {\n    await API.pinAnnouncement(announcementID);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"pinning this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Unpin an announcement in an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} announcementID\n */\n\nexport const unpinAnnouncement = announcementID => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    await API.unpinAnnouncement(announcementID);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"unpinning this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Close an announcement for a given courseID's session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} announcementID\n */\n\nexport const closeAnnouncement = announcementID => async dispatch => {\n  dispatch(startLoading());\n\n  try {\n    await API.unpinAnnouncement(announcementID);\n    await API.closeAnnouncement(announcementID);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"closing this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Receive the question id for the question the TA is going to help on\n * @param {Question} question\n * @returns {Function} redux thunk function\n */\n\nexport const helpStudent = question => async dispatch => {\n  dispatch(startLoading());\n\n  try {\n    await API.helpStudent(question._id);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setCustomServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Receive the question id for the question the TA is going to help on\n * @param {*} courseID\n * @param {*} userID\n * @param {*} questionID\n * @param {*} assistant\n */\n\nexport const finishHelpingStudent = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    const activeQuestion = selectors.getActiveQuestion(getState());\n\n    if (!activeQuestion) {\n      return;\n    }\n\n    await API.closeQuestion(activeQuestion._id);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setCustomServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * @function userStafferOf\n * Determine whether or not user is a TA (staffer) in a session\n * @returns {Boolean} user in staffers array\n */\n\nexport const userStafferOf = () => (dispatch, getState) => {\n  const session = selectors.getSession(getState());\n  const userID = selectors.getUserID(getState());\n\n  if (!(session === null || session === void 0 ? void 0 : session.staffers)) {\n    return false;\n  }\n\n  for (const staffer of session === null || session === void 0 ? void 0 : session.staffers) {\n    var _staffer$staffer;\n\n    if ((staffer === null || staffer === void 0 ? void 0 : staffer._id) === userID || (staffer === null || staffer === void 0 ? void 0 : (_staffer$staffer = staffer.staffer) === null || _staffer$staffer === void 0 ? void 0 : _staffer$staffer.assistant) === userID) {\n      return true;\n    }\n  }\n\n  return false;\n};","map":{"version":3,"sources":["/Users/jasmineharris/Desktop/Elite/woto/src/redux/courses/actions/ta.js"],"names":["API","fetchSession","startLoading","stopLoading","clearError","setServerError","setSuccessMessage","setError","setCustomServerError","updateCourse","editProfile","selectors","clearSession","setSession","openSession","session","dispatch","getState","courseID","getCourseID","course","getCourse","meetingURL","courseWithSession","activeSession","error","console","closeSession","courseWithNoSession","joinSession","joinSessionAsStaffer","leaveSession","leaveSessionAsStaffer","editSession","changes","makeAnnouncement","message","user","getUser","name","pinAnnouncement","announcementID","unpinAnnouncement","closeAnnouncement","helpStudent","question","_id","finishHelpingStudent","activeQuestion","getActiveQuestion","closeQuestion","userStafferOf","getSession","userID","getUserID","staffers","staffer","assistant"],"mappings":"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","sourcesContent":["import API from \"../../../api/API\";\nimport { fetchSession } from \"./fetches\";\nimport {\n  startLoading,\n  stopLoading,\n  clearError,\n  setServerError,\n  setSuccessMessage,\n  setError,\n  setCustomServerError,\n} from \"../../status/actionCreators\";\nimport { updateCourse } from \"../../sorted-courses/actionCreators\";\nimport { editProfile } from \"../../auth/actionCreators\";\nimport selectors from \"../../selectors\";\nimport { clearSession, setSession } from \"./actionCreators\";\n\n/**\n * Opens a new session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} session - session object with start and end time\n * @param {*} meetingURL\n */\nexport const openSession = (session) => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n  const course = selectors.getCourse(getState());\n  const { meetingURL } = session;\n  try {\n    await API.openSession(courseID, session);\n    if (meetingURL) {\n      await dispatch(editProfile({ meetingURL }, false));\n    }\n\n    // set active session\n    // @TODO temporary refetch whole session since openSession returns different session object\n    // dispatch(actionCreators.setSession(courseID, newSession));\n    const courseWithSession = { ...course, activeSession: true };\n    await dispatch(fetchSession());\n    dispatch(updateCourse(courseWithSession));\n\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Closes an active session for the given courseID\n * @param {*} courseID\n * @param {*} userID\n */\nexport const closeSession = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n  const course = selectors.getCourse(getState());\n  try {\n    await API.closeSession(courseID);\n    dispatch(clearSession(courseID));\n\n    // update sorted courses\n    const courseWithNoSession = { ...course, activeSession: false };\n    dispatch(updateCourse(courseWithNoSession));\n\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"closing this session\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Join a session as a staffer\n * @param {*} courseID\n * @param {*} userID\n */\nexport const joinSession = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n\n  try {\n    await API.joinSessionAsStaffer(courseID);\n    // await dispatch(actionCreators.setSession(courseID, session));\n    // @TODO temporary refetch whole session since openSession returns different session object\n    await dispatch(fetchSession());\n\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Leave the session as a staffer (does not close the session)\n * @param {*} courseID\n * @param {*} userID\n */\nexport const leaveSession = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n  const courseID = selectors.getCourseID(getState());\n\n  try {\n    await API.leaveSessionAsStaffer(courseID);\n    await dispatch(fetchSession());\n\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"leaving this session\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Edit the active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} changes\n * @param {*} meetingURL\n */\nexport const editSession = (changes, meetingURL) => async (\n  dispatch,\n  getState\n) => {\n  const courseID = selectors.getCourseID(getState());\n\n  dispatch(startLoading());\n  try {\n    if (meetingURL) {\n      await dispatch(editProfile({ meetingURL }, false));\n    }\n    const session = await API.editSession(courseID, changes);\n    dispatch(setSession(courseID, session));\n    dispatch(clearError());\n    dispatch(setSuccessMessage(\"Edited session\"));\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Make an announcement in an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} userName - user's name\n * @param {*} message\n */\nexport const makeAnnouncement = (message, meetingURL) => async (\n  dispatch,\n  getState\n) => {\n  const courseID = selectors.getCourseID(getState());\n  const user = selectors.getUser(getState());\n  dispatch(startLoading());\n\n  try {\n    await API.makeAnnouncement(courseID, message, user.name, meetingURL);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"making this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Pin an announcement in an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} announcementID\n */\nexport const pinAnnouncement = (announcementID) => async (dispatch) => {\n  dispatch(startLoading());\n\n  try {\n    await API.pinAnnouncement(announcementID);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"pinning this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Unpin an announcement in an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} announcementID\n */\nexport const unpinAnnouncement = (announcementID) => async (\n  dispatch,\n  getState\n) => {\n  dispatch(startLoading());\n\n  try {\n    await API.unpinAnnouncement(announcementID);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"unpinning this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Close an announcement for a given courseID's session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} announcementID\n */\nexport const closeAnnouncement = (announcementID) => async (dispatch) => {\n  dispatch(startLoading());\n\n  try {\n    await API.unpinAnnouncement(announcementID);\n    await API.closeAnnouncement(announcementID);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"closing this announcement\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Receive the question id for the question the TA is going to help on\n * @param {Question} question\n * @returns {Function} redux thunk function\n */\nexport const helpStudent = (question) => async (dispatch) => {\n  dispatch(startLoading());\n\n  try {\n    await API.helpStudent(question._id);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setCustomServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Receive the question id for the question the TA is going to help on\n * @param {*} courseID\n * @param {*} userID\n * @param {*} questionID\n * @param {*} assistant\n */\nexport const finishHelpingStudent = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    const activeQuestion = selectors.getActiveQuestion(getState());\n    if (!activeQuestion) {\n      return;\n    }\n    await API.closeQuestion(activeQuestion._id);\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setCustomServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * @function userStafferOf\n * Determine whether or not user is a TA (staffer) in a session\n * @returns {Boolean} user in staffers array\n */\nexport const userStafferOf = () => (dispatch, getState) => {\n  const session = selectors.getSession(getState());\n  const userID = selectors.getUserID(getState());\n  if (!session?.staffers) {\n    return false;\n  }\n  for (const staffer of session?.staffers) {\n    if (staffer?._id === userID || staffer?.staffer?.assistant === userID) {\n      return true;\n    }\n  }\n  return false;\n};\n"]},"metadata":{},"sourceType":"module"}