{"ast":null,"code":"// Generated by CoffeeScript 1.10.0\nvar DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, GRAPHS, L33T_TABLE, RANKED_DICTIONARIES, REGEXEN, adjacency_graphs, build_ranked_dict, frequency_lists, lst, matching, name, scoring;\nfrequency_lists = require('./frequency_lists');\nadjacency_graphs = require('./adjacency_graphs');\nscoring = require('./scoring');\n\nbuild_ranked_dict = function (ordered_list) {\n  var i, len1, o, result, word;\n  result = {};\n  i = 1;\n\n  for (o = 0, len1 = ordered_list.length; o < len1; o++) {\n    word = ordered_list[o];\n    result[word] = i;\n    i += 1;\n  }\n\n  return result;\n};\n\nRANKED_DICTIONARIES = {};\n\nfor (name in frequency_lists) {\n  lst = frequency_lists[name];\n  RANKED_DICTIONARIES[name] = build_ranked_dict(lst);\n}\n\nGRAPHS = {\n  qwerty: adjacency_graphs.qwerty,\n  dvorak: adjacency_graphs.dvorak,\n  keypad: adjacency_graphs.keypad,\n  mac_keypad: adjacency_graphs.mac_keypad\n};\nL33T_TABLE = {\n  a: ['4', '@'],\n  b: ['8'],\n  c: ['(', '{', '[', '<'],\n  e: ['3'],\n  g: ['6', '9'],\n  i: ['1', '!', '|'],\n  l: ['1', '|', '7'],\n  o: ['0'],\n  s: ['$', '5'],\n  t: ['+', '7'],\n  x: ['%'],\n  z: ['2']\n};\nREGEXEN = {\n  recent_year: /19\\d\\d|200\\d|201\\d/g\n};\nDATE_MAX_YEAR = 2050;\nDATE_MIN_YEAR = 1000;\nDATE_SPLITS = {\n  4: [[1, 2], [2, 3]],\n  5: [[1, 3], [2, 3]],\n  6: [[1, 2], [2, 4], [4, 5]],\n  7: [[1, 3], [2, 3], [4, 5], [4, 6]],\n  8: [[2, 4], [4, 6]]\n};\nmatching = {\n  empty: function (obj) {\n    var k;\n    return function () {\n      var results;\n      results = [];\n\n      for (k in obj) {\n        results.push(k);\n      }\n\n      return results;\n    }().length === 0;\n  },\n  extend: function (lst, lst2) {\n    return lst.push.apply(lst, lst2);\n  },\n  translate: function (string, chr_map) {\n    var chr;\n    return function () {\n      var len1, o, ref, results;\n      ref = string.split('');\n      results = [];\n\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        chr = ref[o];\n        results.push(chr_map[chr] || chr);\n      }\n\n      return results;\n    }().join('');\n  },\n  mod: function (n, m) {\n    return (n % m + m) % m;\n  },\n  sorted: function (matches) {\n    return matches.sort(function (m1, m2) {\n      return m1.i - m2.i || m1.j - m2.j;\n    });\n  },\n  omnimatch: function (password) {\n    var len1, matcher, matchers, matches, o;\n    matches = [];\n    matchers = [this.dictionary_match, this.reverse_dictionary_match, this.l33t_match, this.spatial_match, this.repeat_match, this.sequence_match, this.regex_match, this.date_match];\n\n    for (o = 0, len1 = matchers.length; o < len1; o++) {\n      matcher = matchers[o];\n      this.extend(matches, matcher.call(this, password));\n    }\n\n    return this.sorted(matches);\n  },\n  dictionary_match: function (password, _ranked_dictionaries) {\n    var dictionary_name, i, j, len, matches, o, p, password_lower, rank, ranked_dict, ref, ref1, ref2, word;\n\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n\n    matches = [];\n    len = password.length;\n    password_lower = password.toLowerCase();\n\n    for (dictionary_name in _ranked_dictionaries) {\n      ranked_dict = _ranked_dictionaries[dictionary_name];\n\n      for (i = o = 0, ref = len; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        for (j = p = ref1 = i, ref2 = len; ref1 <= ref2 ? p < ref2 : p > ref2; j = ref1 <= ref2 ? ++p : --p) {\n          if (password_lower.slice(i, +j + 1 || 9e9) in ranked_dict) {\n            word = password_lower.slice(i, +j + 1 || 9e9);\n            rank = ranked_dict[word];\n            matches.push({\n              pattern: 'dictionary',\n              i: i,\n              j: j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matched_word: word,\n              rank: rank,\n              dictionary_name: dictionary_name,\n              reversed: false,\n              l33t: false\n            });\n          }\n        }\n      }\n    }\n\n    return this.sorted(matches);\n  },\n  reverse_dictionary_match: function (password, _ranked_dictionaries) {\n    var len1, match, matches, o, ref, reversed_password;\n\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n\n    reversed_password = password.split('').reverse().join('');\n    matches = this.dictionary_match(reversed_password, _ranked_dictionaries);\n\n    for (o = 0, len1 = matches.length; o < len1; o++) {\n      match = matches[o];\n      match.token = match.token.split('').reverse().join('');\n      match.reversed = true;\n      ref = [password.length - 1 - match.j, password.length - 1 - match.i], match.i = ref[0], match.j = ref[1];\n    }\n\n    return this.sorted(matches);\n  },\n  set_user_input_dictionary: function (ordered_list) {\n    return RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict(ordered_list.slice());\n  },\n  relevant_l33t_subtable: function (password, table) {\n    var chr, len1, letter, o, password_chars, ref, relevant_subs, sub, subs, subtable;\n    password_chars = {};\n    ref = password.split('');\n\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      chr = ref[o];\n      password_chars[chr] = true;\n    }\n\n    subtable = {};\n\n    for (letter in table) {\n      subs = table[letter];\n\n      relevant_subs = function () {\n        var len2, p, results;\n        results = [];\n\n        for (p = 0, len2 = subs.length; p < len2; p++) {\n          sub = subs[p];\n\n          if (sub in password_chars) {\n            results.push(sub);\n          }\n        }\n\n        return results;\n      }();\n\n      if (relevant_subs.length > 0) {\n        subtable[letter] = relevant_subs;\n      }\n    }\n\n    return subtable;\n  },\n  enumerate_l33t_subs: function (table) {\n    var chr, dedup, helper, k, keys, l33t_chr, len1, len2, o, p, ref, sub, sub_dict, sub_dicts, subs;\n\n    keys = function () {\n      var results;\n      results = [];\n\n      for (k in table) {\n        results.push(k);\n      }\n\n      return results;\n    }();\n\n    subs = [[]];\n\n    dedup = function (subs) {\n      var assoc, deduped, label, len1, members, o, sub, v;\n      deduped = [];\n      members = {};\n\n      for (o = 0, len1 = subs.length; o < len1; o++) {\n        sub = subs[o];\n\n        assoc = function () {\n          var len2, p, results;\n          results = [];\n\n          for (v = p = 0, len2 = sub.length; p < len2; v = ++p) {\n            k = sub[v];\n            results.push([k, v]);\n          }\n\n          return results;\n        }();\n\n        assoc.sort();\n\n        label = function () {\n          var len2, p, results;\n          results = [];\n\n          for (v = p = 0, len2 = assoc.length; p < len2; v = ++p) {\n            k = assoc[v];\n            results.push(k + ',' + v);\n          }\n\n          return results;\n        }().join('-');\n\n        if (!(label in members)) {\n          members[label] = true;\n          deduped.push(sub);\n        }\n      }\n\n      return deduped;\n    };\n\n    helper = function (keys) {\n      var dup_l33t_index, first_key, i, l33t_chr, len1, len2, next_subs, o, p, q, ref, ref1, rest_keys, sub, sub_alternative, sub_extension;\n\n      if (!keys.length) {\n        return;\n      }\n\n      first_key = keys[0];\n      rest_keys = keys.slice(1);\n      next_subs = [];\n      ref = table[first_key];\n\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        l33t_chr = ref[o];\n\n        for (p = 0, len2 = subs.length; p < len2; p++) {\n          sub = subs[p];\n          dup_l33t_index = -1;\n\n          for (i = q = 0, ref1 = sub.length; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n            if (sub[i][0] === l33t_chr) {\n              dup_l33t_index = i;\n              break;\n            }\n          }\n\n          if (dup_l33t_index === -1) {\n            sub_extension = sub.concat([[l33t_chr, first_key]]);\n            next_subs.push(sub_extension);\n          } else {\n            sub_alternative = sub.slice(0);\n            sub_alternative.splice(dup_l33t_index, 1);\n            sub_alternative.push([l33t_chr, first_key]);\n            next_subs.push(sub);\n            next_subs.push(sub_alternative);\n          }\n        }\n      }\n\n      subs = dedup(next_subs);\n      return helper(rest_keys);\n    };\n\n    helper(keys);\n    sub_dicts = [];\n\n    for (o = 0, len1 = subs.length; o < len1; o++) {\n      sub = subs[o];\n      sub_dict = {};\n\n      for (p = 0, len2 = sub.length; p < len2; p++) {\n        ref = sub[p], l33t_chr = ref[0], chr = ref[1];\n        sub_dict[l33t_chr] = chr;\n      }\n\n      sub_dicts.push(sub_dict);\n    }\n\n    return sub_dicts;\n  },\n  l33t_match: function (password, _ranked_dictionaries, _l33t_table) {\n    var chr, k, len1, len2, match, match_sub, matches, o, p, ref, ref1, sub, subbed_chr, subbed_password, token, v;\n\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n\n    if (_l33t_table == null) {\n      _l33t_table = L33T_TABLE;\n    }\n\n    matches = [];\n    ref = this.enumerate_l33t_subs(this.relevant_l33t_subtable(password, _l33t_table));\n\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      sub = ref[o];\n\n      if (this.empty(sub)) {\n        break;\n      }\n\n      subbed_password = this.translate(password, sub);\n      ref1 = this.dictionary_match(subbed_password, _ranked_dictionaries);\n\n      for (p = 0, len2 = ref1.length; p < len2; p++) {\n        match = ref1[p];\n        token = password.slice(match.i, +match.j + 1 || 9e9);\n\n        if (token.toLowerCase() === match.matched_word) {\n          continue;\n        }\n\n        match_sub = {};\n\n        for (subbed_chr in sub) {\n          chr = sub[subbed_chr];\n\n          if (token.indexOf(subbed_chr) !== -1) {\n            match_sub[subbed_chr] = chr;\n          }\n        }\n\n        match.l33t = true;\n        match.token = token;\n        match.sub = match_sub;\n\n        match.sub_display = function () {\n          var results;\n          results = [];\n\n          for (k in match_sub) {\n            v = match_sub[k];\n            results.push(k + \" -> \" + v);\n          }\n\n          return results;\n        }().join(', ');\n\n        matches.push(match);\n      }\n    }\n\n    return this.sorted(matches.filter(function (match) {\n      return match.token.length > 1;\n    }));\n  },\n  spatial_match: function (password, _graphs) {\n    var graph, graph_name, matches;\n\n    if (_graphs == null) {\n      _graphs = GRAPHS;\n    }\n\n    matches = [];\n\n    for (graph_name in _graphs) {\n      graph = _graphs[graph_name];\n      this.extend(matches, this.spatial_match_helper(password, graph, graph_name));\n    }\n\n    return this.sorted(matches);\n  },\n  SHIFTED_RX: /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/,\n  spatial_match_helper: function (password, graph, graph_name) {\n    var adj, adjacents, cur_char, cur_direction, found, found_direction, i, j, last_direction, len1, matches, o, prev_char, shifted_count, turns;\n    matches = [];\n    i = 0;\n\n    while (i < password.length - 1) {\n      j = i + 1;\n      last_direction = null;\n      turns = 0;\n\n      if ((graph_name === 'qwerty' || graph_name === 'dvorak') && this.SHIFTED_RX.exec(password.charAt(i))) {\n        shifted_count = 1;\n      } else {\n        shifted_count = 0;\n      }\n\n      while (true) {\n        prev_char = password.charAt(j - 1);\n        found = false;\n        found_direction = -1;\n        cur_direction = -1;\n        adjacents = graph[prev_char] || [];\n\n        if (j < password.length) {\n          cur_char = password.charAt(j);\n\n          for (o = 0, len1 = adjacents.length; o < len1; o++) {\n            adj = adjacents[o];\n            cur_direction += 1;\n\n            if (adj && adj.indexOf(cur_char) !== -1) {\n              found = true;\n              found_direction = cur_direction;\n\n              if (adj.indexOf(cur_char) === 1) {\n                shifted_count += 1;\n              }\n\n              if (last_direction !== found_direction) {\n                turns += 1;\n                last_direction = found_direction;\n              }\n\n              break;\n            }\n          }\n        }\n\n        if (found) {\n          j += 1;\n        } else {\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i: i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graph_name,\n              turns: turns,\n              shifted_count: shifted_count\n            });\n          }\n\n          i = j;\n          break;\n        }\n      }\n    }\n\n    return matches;\n  },\n  repeat_match: function (password) {\n    var base_analysis, base_guesses, base_matches, base_token, greedy, greedy_match, i, j, lastIndex, lazy, lazy_anchored, lazy_match, match, matches, ref;\n    matches = [];\n    greedy = /(.+)\\1+/g;\n    lazy = /(.+?)\\1+/g;\n    lazy_anchored = /^(.+?)\\1+$/;\n    lastIndex = 0;\n\n    while (lastIndex < password.length) {\n      greedy.lastIndex = lazy.lastIndex = lastIndex;\n      greedy_match = greedy.exec(password);\n      lazy_match = lazy.exec(password);\n\n      if (greedy_match == null) {\n        break;\n      }\n\n      if (greedy_match[0].length > lazy_match[0].length) {\n        match = greedy_match;\n        base_token = lazy_anchored.exec(match[0])[1];\n      } else {\n        match = lazy_match;\n        base_token = match[1];\n      }\n\n      ref = [match.index, match.index + match[0].length - 1], i = ref[0], j = ref[1];\n      base_analysis = scoring.most_guessable_match_sequence(base_token, this.omnimatch(base_token));\n      base_matches = base_analysis.sequence;\n      base_guesses = base_analysis.guesses;\n      matches.push({\n        pattern: 'repeat',\n        i: i,\n        j: j,\n        token: match[0],\n        base_token: base_token,\n        base_guesses: base_guesses,\n        base_matches: base_matches,\n        repeat_count: match[0].length / base_token.length\n      });\n      lastIndex = j + 1;\n    }\n\n    return matches;\n  },\n  MAX_DELTA: 5,\n  sequence_match: function (password) {\n    var delta, i, j, k, last_delta, o, ref, result, update;\n\n    if (password.length === 1) {\n      return [];\n    }\n\n    update = function (_this) {\n      return function (i, j, delta) {\n        var ref, sequence_name, sequence_space, token;\n\n        if (j - i > 1 || Math.abs(delta) === 1) {\n          if (0 < (ref = Math.abs(delta)) && ref <= _this.MAX_DELTA) {\n            token = password.slice(i, +j + 1 || 9e9);\n\n            if (/^[a-z]+$/.test(token)) {\n              sequence_name = 'lower';\n              sequence_space = 26;\n            } else if (/^[A-Z]+$/.test(token)) {\n              sequence_name = 'upper';\n              sequence_space = 26;\n            } else if (/^\\d+$/.test(token)) {\n              sequence_name = 'digits';\n              sequence_space = 10;\n            } else {\n              sequence_name = 'unicode';\n              sequence_space = 26;\n            }\n\n            return result.push({\n              pattern: 'sequence',\n              i: i,\n              j: j,\n              token: password.slice(i, +j + 1 || 9e9),\n              sequence_name: sequence_name,\n              sequence_space: sequence_space,\n              ascending: delta > 0\n            });\n          }\n        }\n      };\n    }(this);\n\n    result = [];\n    i = 0;\n    last_delta = null;\n\n    for (k = o = 1, ref = password.length; 1 <= ref ? o < ref : o > ref; k = 1 <= ref ? ++o : --o) {\n      delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n\n      if (last_delta == null) {\n        last_delta = delta;\n      }\n\n      if (delta === last_delta) {\n        continue;\n      }\n\n      j = k - 1;\n      update(i, j, last_delta);\n      i = j;\n      last_delta = delta;\n    }\n\n    update(i, password.length - 1, last_delta);\n    return result;\n  },\n  regex_match: function (password, _regexen) {\n    var matches, regex, rx_match, token;\n\n    if (_regexen == null) {\n      _regexen = REGEXEN;\n    }\n\n    matches = [];\n\n    for (name in _regexen) {\n      regex = _regexen[name];\n      regex.lastIndex = 0;\n\n      while (rx_match = regex.exec(password)) {\n        token = rx_match[0];\n        matches.push({\n          pattern: 'regex',\n          token: token,\n          i: rx_match.index,\n          j: rx_match.index + rx_match[0].length - 1,\n          regex_name: name,\n          regex_match: rx_match\n        });\n      }\n    }\n\n    return this.sorted(matches);\n  },\n  date_match: function (password) {\n    var best_candidate, candidate, candidates, distance, dmy, i, j, k, l, len1, len2, matches, maybe_date_no_separator, maybe_date_with_separator, metric, min_distance, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rx_match, s, t, token;\n    matches = [];\n    maybe_date_no_separator = /^\\d{4,8}$/;\n    maybe_date_with_separator = /^(\\d{1,4})([\\s\\/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\n\n    for (i = o = 0, ref = password.length - 4; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n      for (j = p = ref1 = i + 3, ref2 = i + 7; ref1 <= ref2 ? p <= ref2 : p >= ref2; j = ref1 <= ref2 ? ++p : --p) {\n        if (j >= password.length) {\n          break;\n        }\n\n        token = password.slice(i, +j + 1 || 9e9);\n\n        if (!maybe_date_no_separator.exec(token)) {\n          continue;\n        }\n\n        candidates = [];\n        ref3 = DATE_SPLITS[token.length];\n\n        for (q = 0, len1 = ref3.length; q < len1; q++) {\n          ref4 = ref3[q], k = ref4[0], l = ref4[1];\n          dmy = this.map_ints_to_dmy([parseInt(token.slice(0, k)), parseInt(token.slice(k, l)), parseInt(token.slice(l))]);\n\n          if (dmy != null) {\n            candidates.push(dmy);\n          }\n        }\n\n        if (!(candidates.length > 0)) {\n          continue;\n        }\n\n        best_candidate = candidates[0];\n\n        metric = function (candidate) {\n          return Math.abs(candidate.year - scoring.REFERENCE_YEAR);\n        };\n\n        min_distance = metric(candidates[0]);\n        ref5 = candidates.slice(1);\n\n        for (r = 0, len2 = ref5.length; r < len2; r++) {\n          candidate = ref5[r];\n          distance = metric(candidate);\n\n          if (distance < min_distance) {\n            ref6 = [candidate, distance], best_candidate = ref6[0], min_distance = ref6[1];\n          }\n        }\n\n        matches.push({\n          pattern: 'date',\n          token: token,\n          i: i,\n          j: j,\n          separator: '',\n          year: best_candidate.year,\n          month: best_candidate.month,\n          day: best_candidate.day\n        });\n      }\n    }\n\n    for (i = s = 0, ref7 = password.length - 6; 0 <= ref7 ? s <= ref7 : s >= ref7; i = 0 <= ref7 ? ++s : --s) {\n      for (j = t = ref8 = i + 5, ref9 = i + 9; ref8 <= ref9 ? t <= ref9 : t >= ref9; j = ref8 <= ref9 ? ++t : --t) {\n        if (j >= password.length) {\n          break;\n        }\n\n        token = password.slice(i, +j + 1 || 9e9);\n        rx_match = maybe_date_with_separator.exec(token);\n\n        if (rx_match == null) {\n          continue;\n        }\n\n        dmy = this.map_ints_to_dmy([parseInt(rx_match[1]), parseInt(rx_match[3]), parseInt(rx_match[4])]);\n\n        if (dmy == null) {\n          continue;\n        }\n\n        matches.push({\n          pattern: 'date',\n          token: token,\n          i: i,\n          j: j,\n          separator: rx_match[2],\n          year: dmy.year,\n          month: dmy.month,\n          day: dmy.day\n        });\n      }\n    }\n\n    return this.sorted(matches.filter(function (match) {\n      var is_submatch, len3, other_match, u;\n      is_submatch = false;\n\n      for (u = 0, len3 = matches.length; u < len3; u++) {\n        other_match = matches[u];\n\n        if (match === other_match) {\n          continue;\n        }\n\n        if (other_match.i <= match.i && other_match.j >= match.j) {\n          is_submatch = true;\n          break;\n        }\n      }\n\n      return !is_submatch;\n    }));\n  },\n  map_ints_to_dmy: function (ints) {\n    var dm, int, len1, len2, len3, o, over_12, over_31, p, possible_year_splits, q, ref, ref1, rest, under_1, y;\n\n    if (ints[1] > 31 || ints[1] <= 0) {\n      return;\n    }\n\n    over_12 = 0;\n    over_31 = 0;\n    under_1 = 0;\n\n    for (o = 0, len1 = ints.length; o < len1; o++) {\n      int = ints[o];\n\n      if (99 < int && int < DATE_MIN_YEAR || int > DATE_MAX_YEAR) {\n        return;\n      }\n\n      if (int > 31) {\n        over_31 += 1;\n      }\n\n      if (int > 12) {\n        over_12 += 1;\n      }\n\n      if (int <= 0) {\n        under_1 += 1;\n      }\n    }\n\n    if (over_31 >= 2 || over_12 === 3 || under_1 >= 2) {\n      return;\n    }\n\n    possible_year_splits = [[ints[2], ints.slice(0, 2)], [ints[0], ints.slice(1, 3)]];\n\n    for (p = 0, len2 = possible_year_splits.length; p < len2; p++) {\n      ref = possible_year_splits[p], y = ref[0], rest = ref[1];\n\n      if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n        dm = this.map_ints_to_dm(rest);\n\n        if (dm != null) {\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        } else {\n          return;\n        }\n      }\n    }\n\n    for (q = 0, len3 = possible_year_splits.length; q < len3; q++) {\n      ref1 = possible_year_splits[q], y = ref1[0], rest = ref1[1];\n      dm = this.map_ints_to_dm(rest);\n\n      if (dm != null) {\n        y = this.two_to_four_digit_year(y);\n        return {\n          year: y,\n          month: dm.month,\n          day: dm.day\n        };\n      }\n    }\n  },\n  map_ints_to_dm: function (ints) {\n    var d, len1, m, o, ref, ref1;\n    ref = [ints, ints.slice().reverse()];\n\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      ref1 = ref[o], d = ref1[0], m = ref1[1];\n\n      if (1 <= d && d <= 31 && 1 <= m && m <= 12) {\n        return {\n          day: d,\n          month: m\n        };\n      }\n    }\n  },\n  two_to_four_digit_year: function (year) {\n    if (year > 99) {\n      return year;\n    } else if (year > 50) {\n      return year + 1900;\n    } else {\n      return year + 2000;\n    }\n  }\n};\nmodule.exports = matching;","map":{"version":3,"sources":["src/matching.coffee"],"names":[],"mappings":"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","sourceRoot":"..","sourcesContent":["// Generated by CoffeeScript 1.10.0\nvar DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, GRAPHS, L33T_TABLE, RANKED_DICTIONARIES, REGEXEN, adjacency_graphs, build_ranked_dict, frequency_lists, lst, matching, name, scoring;\n\nfrequency_lists = require('./frequency_lists');\n\nadjacency_graphs = require('./adjacency_graphs');\n\nscoring = require('./scoring');\n\nbuild_ranked_dict = function(ordered_list) {\n  var i, len1, o, result, word;\n  result = {};\n  i = 1;\n  for (o = 0, len1 = ordered_list.length; o < len1; o++) {\n    word = ordered_list[o];\n    result[word] = i;\n    i += 1;\n  }\n  return result;\n};\n\nRANKED_DICTIONARIES = {};\n\nfor (name in frequency_lists) {\n  lst = frequency_lists[name];\n  RANKED_DICTIONARIES[name] = build_ranked_dict(lst);\n}\n\nGRAPHS = {\n  qwerty: adjacency_graphs.qwerty,\n  dvorak: adjacency_graphs.dvorak,\n  keypad: adjacency_graphs.keypad,\n  mac_keypad: adjacency_graphs.mac_keypad\n};\n\nL33T_TABLE = {\n  a: ['4', '@'],\n  b: ['8'],\n  c: ['(', '{', '[', '<'],\n  e: ['3'],\n  g: ['6', '9'],\n  i: ['1', '!', '|'],\n  l: ['1', '|', '7'],\n  o: ['0'],\n  s: ['$', '5'],\n  t: ['+', '7'],\n  x: ['%'],\n  z: ['2']\n};\n\nREGEXEN = {\n  recent_year: /19\\d\\d|200\\d|201\\d/g\n};\n\nDATE_MAX_YEAR = 2050;\n\nDATE_MIN_YEAR = 1000;\n\nDATE_SPLITS = {\n  4: [[1, 2], [2, 3]],\n  5: [[1, 3], [2, 3]],\n  6: [[1, 2], [2, 4], [4, 5]],\n  7: [[1, 3], [2, 3], [4, 5], [4, 6]],\n  8: [[2, 4], [4, 6]]\n};\n\nmatching = {\n  empty: function(obj) {\n    var k;\n    return ((function() {\n      var results;\n      results = [];\n      for (k in obj) {\n        results.push(k);\n      }\n      return results;\n    })()).length === 0;\n  },\n  extend: function(lst, lst2) {\n    return lst.push.apply(lst, lst2);\n  },\n  translate: function(string, chr_map) {\n    var chr;\n    return ((function() {\n      var len1, o, ref, results;\n      ref = string.split('');\n      results = [];\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        chr = ref[o];\n        results.push(chr_map[chr] || chr);\n      }\n      return results;\n    })()).join('');\n  },\n  mod: function(n, m) {\n    return ((n % m) + m) % m;\n  },\n  sorted: function(matches) {\n    return matches.sort(function(m1, m2) {\n      return (m1.i - m2.i) || (m1.j - m2.j);\n    });\n  },\n  omnimatch: function(password) {\n    var len1, matcher, matchers, matches, o;\n    matches = [];\n    matchers = [this.dictionary_match, this.reverse_dictionary_match, this.l33t_match, this.spatial_match, this.repeat_match, this.sequence_match, this.regex_match, this.date_match];\n    for (o = 0, len1 = matchers.length; o < len1; o++) {\n      matcher = matchers[o];\n      this.extend(matches, matcher.call(this, password));\n    }\n    return this.sorted(matches);\n  },\n  dictionary_match: function(password, _ranked_dictionaries) {\n    var dictionary_name, i, j, len, matches, o, p, password_lower, rank, ranked_dict, ref, ref1, ref2, word;\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n    matches = [];\n    len = password.length;\n    password_lower = password.toLowerCase();\n    for (dictionary_name in _ranked_dictionaries) {\n      ranked_dict = _ranked_dictionaries[dictionary_name];\n      for (i = o = 0, ref = len; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {\n        for (j = p = ref1 = i, ref2 = len; ref1 <= ref2 ? p < ref2 : p > ref2; j = ref1 <= ref2 ? ++p : --p) {\n          if (password_lower.slice(i, +j + 1 || 9e9) in ranked_dict) {\n            word = password_lower.slice(i, +j + 1 || 9e9);\n            rank = ranked_dict[word];\n            matches.push({\n              pattern: 'dictionary',\n              i: i,\n              j: j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matched_word: word,\n              rank: rank,\n              dictionary_name: dictionary_name,\n              reversed: false,\n              l33t: false\n            });\n          }\n        }\n      }\n    }\n    return this.sorted(matches);\n  },\n  reverse_dictionary_match: function(password, _ranked_dictionaries) {\n    var len1, match, matches, o, ref, reversed_password;\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n    reversed_password = password.split('').reverse().join('');\n    matches = this.dictionary_match(reversed_password, _ranked_dictionaries);\n    for (o = 0, len1 = matches.length; o < len1; o++) {\n      match = matches[o];\n      match.token = match.token.split('').reverse().join('');\n      match.reversed = true;\n      ref = [password.length - 1 - match.j, password.length - 1 - match.i], match.i = ref[0], match.j = ref[1];\n    }\n    return this.sorted(matches);\n  },\n  set_user_input_dictionary: function(ordered_list) {\n    return RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict(ordered_list.slice());\n  },\n  relevant_l33t_subtable: function(password, table) {\n    var chr, len1, letter, o, password_chars, ref, relevant_subs, sub, subs, subtable;\n    password_chars = {};\n    ref = password.split('');\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      chr = ref[o];\n      password_chars[chr] = true;\n    }\n    subtable = {};\n    for (letter in table) {\n      subs = table[letter];\n      relevant_subs = (function() {\n        var len2, p, results;\n        results = [];\n        for (p = 0, len2 = subs.length; p < len2; p++) {\n          sub = subs[p];\n          if (sub in password_chars) {\n            results.push(sub);\n          }\n        }\n        return results;\n      })();\n      if (relevant_subs.length > 0) {\n        subtable[letter] = relevant_subs;\n      }\n    }\n    return subtable;\n  },\n  enumerate_l33t_subs: function(table) {\n    var chr, dedup, helper, k, keys, l33t_chr, len1, len2, o, p, ref, sub, sub_dict, sub_dicts, subs;\n    keys = (function() {\n      var results;\n      results = [];\n      for (k in table) {\n        results.push(k);\n      }\n      return results;\n    })();\n    subs = [[]];\n    dedup = function(subs) {\n      var assoc, deduped, label, len1, members, o, sub, v;\n      deduped = [];\n      members = {};\n      for (o = 0, len1 = subs.length; o < len1; o++) {\n        sub = subs[o];\n        assoc = (function() {\n          var len2, p, results;\n          results = [];\n          for (v = p = 0, len2 = sub.length; p < len2; v = ++p) {\n            k = sub[v];\n            results.push([k, v]);\n          }\n          return results;\n        })();\n        assoc.sort();\n        label = ((function() {\n          var len2, p, results;\n          results = [];\n          for (v = p = 0, len2 = assoc.length; p < len2; v = ++p) {\n            k = assoc[v];\n            results.push(k + ',' + v);\n          }\n          return results;\n        })()).join('-');\n        if (!(label in members)) {\n          members[label] = true;\n          deduped.push(sub);\n        }\n      }\n      return deduped;\n    };\n    helper = function(keys) {\n      var dup_l33t_index, first_key, i, l33t_chr, len1, len2, next_subs, o, p, q, ref, ref1, rest_keys, sub, sub_alternative, sub_extension;\n      if (!keys.length) {\n        return;\n      }\n      first_key = keys[0];\n      rest_keys = keys.slice(1);\n      next_subs = [];\n      ref = table[first_key];\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        l33t_chr = ref[o];\n        for (p = 0, len2 = subs.length; p < len2; p++) {\n          sub = subs[p];\n          dup_l33t_index = -1;\n          for (i = q = 0, ref1 = sub.length; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n            if (sub[i][0] === l33t_chr) {\n              dup_l33t_index = i;\n              break;\n            }\n          }\n          if (dup_l33t_index === -1) {\n            sub_extension = sub.concat([[l33t_chr, first_key]]);\n            next_subs.push(sub_extension);\n          } else {\n            sub_alternative = sub.slice(0);\n            sub_alternative.splice(dup_l33t_index, 1);\n            sub_alternative.push([l33t_chr, first_key]);\n            next_subs.push(sub);\n            next_subs.push(sub_alternative);\n          }\n        }\n      }\n      subs = dedup(next_subs);\n      return helper(rest_keys);\n    };\n    helper(keys);\n    sub_dicts = [];\n    for (o = 0, len1 = subs.length; o < len1; o++) {\n      sub = subs[o];\n      sub_dict = {};\n      for (p = 0, len2 = sub.length; p < len2; p++) {\n        ref = sub[p], l33t_chr = ref[0], chr = ref[1];\n        sub_dict[l33t_chr] = chr;\n      }\n      sub_dicts.push(sub_dict);\n    }\n    return sub_dicts;\n  },\n  l33t_match: function(password, _ranked_dictionaries, _l33t_table) {\n    var chr, k, len1, len2, match, match_sub, matches, o, p, ref, ref1, sub, subbed_chr, subbed_password, token, v;\n    if (_ranked_dictionaries == null) {\n      _ranked_dictionaries = RANKED_DICTIONARIES;\n    }\n    if (_l33t_table == null) {\n      _l33t_table = L33T_TABLE;\n    }\n    matches = [];\n    ref = this.enumerate_l33t_subs(this.relevant_l33t_subtable(password, _l33t_table));\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      sub = ref[o];\n      if (this.empty(sub)) {\n        break;\n      }\n      subbed_password = this.translate(password, sub);\n      ref1 = this.dictionary_match(subbed_password, _ranked_dictionaries);\n      for (p = 0, len2 = ref1.length; p < len2; p++) {\n        match = ref1[p];\n        token = password.slice(match.i, +match.j + 1 || 9e9);\n        if (token.toLowerCase() === match.matched_word) {\n          continue;\n        }\n        match_sub = {};\n        for (subbed_chr in sub) {\n          chr = sub[subbed_chr];\n          if (token.indexOf(subbed_chr) !== -1) {\n            match_sub[subbed_chr] = chr;\n          }\n        }\n        match.l33t = true;\n        match.token = token;\n        match.sub = match_sub;\n        match.sub_display = ((function() {\n          var results;\n          results = [];\n          for (k in match_sub) {\n            v = match_sub[k];\n            results.push(k + \" -> \" + v);\n          }\n          return results;\n        })()).join(', ');\n        matches.push(match);\n      }\n    }\n    return this.sorted(matches.filter(function(match) {\n      return match.token.length > 1;\n    }));\n  },\n  spatial_match: function(password, _graphs) {\n    var graph, graph_name, matches;\n    if (_graphs == null) {\n      _graphs = GRAPHS;\n    }\n    matches = [];\n    for (graph_name in _graphs) {\n      graph = _graphs[graph_name];\n      this.extend(matches, this.spatial_match_helper(password, graph, graph_name));\n    }\n    return this.sorted(matches);\n  },\n  SHIFTED_RX: /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/,\n  spatial_match_helper: function(password, graph, graph_name) {\n    var adj, adjacents, cur_char, cur_direction, found, found_direction, i, j, last_direction, len1, matches, o, prev_char, shifted_count, turns;\n    matches = [];\n    i = 0;\n    while (i < password.length - 1) {\n      j = i + 1;\n      last_direction = null;\n      turns = 0;\n      if ((graph_name === 'qwerty' || graph_name === 'dvorak') && this.SHIFTED_RX.exec(password.charAt(i))) {\n        shifted_count = 1;\n      } else {\n        shifted_count = 0;\n      }\n      while (true) {\n        prev_char = password.charAt(j - 1);\n        found = false;\n        found_direction = -1;\n        cur_direction = -1;\n        adjacents = graph[prev_char] || [];\n        if (j < password.length) {\n          cur_char = password.charAt(j);\n          for (o = 0, len1 = adjacents.length; o < len1; o++) {\n            adj = adjacents[o];\n            cur_direction += 1;\n            if (adj && adj.indexOf(cur_char) !== -1) {\n              found = true;\n              found_direction = cur_direction;\n              if (adj.indexOf(cur_char) === 1) {\n                shifted_count += 1;\n              }\n              if (last_direction !== found_direction) {\n                turns += 1;\n                last_direction = found_direction;\n              }\n              break;\n            }\n          }\n        }\n        if (found) {\n          j += 1;\n        } else {\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i: i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graph_name,\n              turns: turns,\n              shifted_count: shifted_count\n            });\n          }\n          i = j;\n          break;\n        }\n      }\n    }\n    return matches;\n  },\n  repeat_match: function(password) {\n    var base_analysis, base_guesses, base_matches, base_token, greedy, greedy_match, i, j, lastIndex, lazy, lazy_anchored, lazy_match, match, matches, ref;\n    matches = [];\n    greedy = /(.+)\\1+/g;\n    lazy = /(.+?)\\1+/g;\n    lazy_anchored = /^(.+?)\\1+$/;\n    lastIndex = 0;\n    while (lastIndex < password.length) {\n      greedy.lastIndex = lazy.lastIndex = lastIndex;\n      greedy_match = greedy.exec(password);\n      lazy_match = lazy.exec(password);\n      if (greedy_match == null) {\n        break;\n      }\n      if (greedy_match[0].length > lazy_match[0].length) {\n        match = greedy_match;\n        base_token = lazy_anchored.exec(match[0])[1];\n      } else {\n        match = lazy_match;\n        base_token = match[1];\n      }\n      ref = [match.index, match.index + match[0].length - 1], i = ref[0], j = ref[1];\n      base_analysis = scoring.most_guessable_match_sequence(base_token, this.omnimatch(base_token));\n      base_matches = base_analysis.sequence;\n      base_guesses = base_analysis.guesses;\n      matches.push({\n        pattern: 'repeat',\n        i: i,\n        j: j,\n        token: match[0],\n        base_token: base_token,\n        base_guesses: base_guesses,\n        base_matches: base_matches,\n        repeat_count: match[0].length / base_token.length\n      });\n      lastIndex = j + 1;\n    }\n    return matches;\n  },\n  MAX_DELTA: 5,\n  sequence_match: function(password) {\n    var delta, i, j, k, last_delta, o, ref, result, update;\n    if (password.length === 1) {\n      return [];\n    }\n    update = (function(_this) {\n      return function(i, j, delta) {\n        var ref, sequence_name, sequence_space, token;\n        if (j - i > 1 || Math.abs(delta) === 1) {\n          if ((0 < (ref = Math.abs(delta)) && ref <= _this.MAX_DELTA)) {\n            token = password.slice(i, +j + 1 || 9e9);\n            if (/^[a-z]+$/.test(token)) {\n              sequence_name = 'lower';\n              sequence_space = 26;\n            } else if (/^[A-Z]+$/.test(token)) {\n              sequence_name = 'upper';\n              sequence_space = 26;\n            } else if (/^\\d+$/.test(token)) {\n              sequence_name = 'digits';\n              sequence_space = 10;\n            } else {\n              sequence_name = 'unicode';\n              sequence_space = 26;\n            }\n            return result.push({\n              pattern: 'sequence',\n              i: i,\n              j: j,\n              token: password.slice(i, +j + 1 || 9e9),\n              sequence_name: sequence_name,\n              sequence_space: sequence_space,\n              ascending: delta > 0\n            });\n          }\n        }\n      };\n    })(this);\n    result = [];\n    i = 0;\n    last_delta = null;\n    for (k = o = 1, ref = password.length; 1 <= ref ? o < ref : o > ref; k = 1 <= ref ? ++o : --o) {\n      delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n      if (last_delta == null) {\n        last_delta = delta;\n      }\n      if (delta === last_delta) {\n        continue;\n      }\n      j = k - 1;\n      update(i, j, last_delta);\n      i = j;\n      last_delta = delta;\n    }\n    update(i, password.length - 1, last_delta);\n    return result;\n  },\n  regex_match: function(password, _regexen) {\n    var matches, regex, rx_match, token;\n    if (_regexen == null) {\n      _regexen = REGEXEN;\n    }\n    matches = [];\n    for (name in _regexen) {\n      regex = _regexen[name];\n      regex.lastIndex = 0;\n      while (rx_match = regex.exec(password)) {\n        token = rx_match[0];\n        matches.push({\n          pattern: 'regex',\n          token: token,\n          i: rx_match.index,\n          j: rx_match.index + rx_match[0].length - 1,\n          regex_name: name,\n          regex_match: rx_match\n        });\n      }\n    }\n    return this.sorted(matches);\n  },\n  date_match: function(password) {\n    var best_candidate, candidate, candidates, distance, dmy, i, j, k, l, len1, len2, matches, maybe_date_no_separator, maybe_date_with_separator, metric, min_distance, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rx_match, s, t, token;\n    matches = [];\n    maybe_date_no_separator = /^\\d{4,8}$/;\n    maybe_date_with_separator = /^(\\d{1,4})([\\s\\/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\n    for (i = o = 0, ref = password.length - 4; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {\n      for (j = p = ref1 = i + 3, ref2 = i + 7; ref1 <= ref2 ? p <= ref2 : p >= ref2; j = ref1 <= ref2 ? ++p : --p) {\n        if (j >= password.length) {\n          break;\n        }\n        token = password.slice(i, +j + 1 || 9e9);\n        if (!maybe_date_no_separator.exec(token)) {\n          continue;\n        }\n        candidates = [];\n        ref3 = DATE_SPLITS[token.length];\n        for (q = 0, len1 = ref3.length; q < len1; q++) {\n          ref4 = ref3[q], k = ref4[0], l = ref4[1];\n          dmy = this.map_ints_to_dmy([parseInt(token.slice(0, k)), parseInt(token.slice(k, l)), parseInt(token.slice(l))]);\n          if (dmy != null) {\n            candidates.push(dmy);\n          }\n        }\n        if (!(candidates.length > 0)) {\n          continue;\n        }\n        best_candidate = candidates[0];\n        metric = function(candidate) {\n          return Math.abs(candidate.year - scoring.REFERENCE_YEAR);\n        };\n        min_distance = metric(candidates[0]);\n        ref5 = candidates.slice(1);\n        for (r = 0, len2 = ref5.length; r < len2; r++) {\n          candidate = ref5[r];\n          distance = metric(candidate);\n          if (distance < min_distance) {\n            ref6 = [candidate, distance], best_candidate = ref6[0], min_distance = ref6[1];\n          }\n        }\n        matches.push({\n          pattern: 'date',\n          token: token,\n          i: i,\n          j: j,\n          separator: '',\n          year: best_candidate.year,\n          month: best_candidate.month,\n          day: best_candidate.day\n        });\n      }\n    }\n    for (i = s = 0, ref7 = password.length - 6; 0 <= ref7 ? s <= ref7 : s >= ref7; i = 0 <= ref7 ? ++s : --s) {\n      for (j = t = ref8 = i + 5, ref9 = i + 9; ref8 <= ref9 ? t <= ref9 : t >= ref9; j = ref8 <= ref9 ? ++t : --t) {\n        if (j >= password.length) {\n          break;\n        }\n        token = password.slice(i, +j + 1 || 9e9);\n        rx_match = maybe_date_with_separator.exec(token);\n        if (rx_match == null) {\n          continue;\n        }\n        dmy = this.map_ints_to_dmy([parseInt(rx_match[1]), parseInt(rx_match[3]), parseInt(rx_match[4])]);\n        if (dmy == null) {\n          continue;\n        }\n        matches.push({\n          pattern: 'date',\n          token: token,\n          i: i,\n          j: j,\n          separator: rx_match[2],\n          year: dmy.year,\n          month: dmy.month,\n          day: dmy.day\n        });\n      }\n    }\n    return this.sorted(matches.filter(function(match) {\n      var is_submatch, len3, other_match, u;\n      is_submatch = false;\n      for (u = 0, len3 = matches.length; u < len3; u++) {\n        other_match = matches[u];\n        if (match === other_match) {\n          continue;\n        }\n        if (other_match.i <= match.i && other_match.j >= match.j) {\n          is_submatch = true;\n          break;\n        }\n      }\n      return !is_submatch;\n    }));\n  },\n  map_ints_to_dmy: function(ints) {\n    var dm, int, len1, len2, len3, o, over_12, over_31, p, possible_year_splits, q, ref, ref1, rest, under_1, y;\n    if (ints[1] > 31 || ints[1] <= 0) {\n      return;\n    }\n    over_12 = 0;\n    over_31 = 0;\n    under_1 = 0;\n    for (o = 0, len1 = ints.length; o < len1; o++) {\n      int = ints[o];\n      if ((99 < int && int < DATE_MIN_YEAR) || int > DATE_MAX_YEAR) {\n        return;\n      }\n      if (int > 31) {\n        over_31 += 1;\n      }\n      if (int > 12) {\n        over_12 += 1;\n      }\n      if (int <= 0) {\n        under_1 += 1;\n      }\n    }\n    if (over_31 >= 2 || over_12 === 3 || under_1 >= 2) {\n      return;\n    }\n    possible_year_splits = [[ints[2], ints.slice(0, 2)], [ints[0], ints.slice(1, 3)]];\n    for (p = 0, len2 = possible_year_splits.length; p < len2; p++) {\n      ref = possible_year_splits[p], y = ref[0], rest = ref[1];\n      if ((DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR)) {\n        dm = this.map_ints_to_dm(rest);\n        if (dm != null) {\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        } else {\n          return;\n        }\n      }\n    }\n    for (q = 0, len3 = possible_year_splits.length; q < len3; q++) {\n      ref1 = possible_year_splits[q], y = ref1[0], rest = ref1[1];\n      dm = this.map_ints_to_dm(rest);\n      if (dm != null) {\n        y = this.two_to_four_digit_year(y);\n        return {\n          year: y,\n          month: dm.month,\n          day: dm.day\n        };\n      }\n    }\n  },\n  map_ints_to_dm: function(ints) {\n    var d, len1, m, o, ref, ref1;\n    ref = [ints, ints.slice().reverse()];\n    for (o = 0, len1 = ref.length; o < len1; o++) {\n      ref1 = ref[o], d = ref1[0], m = ref1[1];\n      if ((1 <= d && d <= 31) && (1 <= m && m <= 12)) {\n        return {\n          day: d,\n          month: m\n        };\n      }\n    }\n  },\n  two_to_four_digit_year: function(year) {\n    if (year > 99) {\n      return year;\n    } else if (year > 50) {\n      return year + 1900;\n    } else {\n      return year + 2000;\n    }\n  }\n};\n\nmodule.exports = matching;\n\n//# sourceMappingURL=matching.js.map\n"]},"metadata":{},"sourceType":"script"}