{"ast":null,"code":"var HashArray = require('hasharray');\n\nvar MAX_CACHE_SIZE = 64;\nvar IS_WHITESPACE = /^[\\s]*$/;\nvar DEFAULT_INTERNATIONALIZE_EXPAND_REGEXES = [{\n  regex: /[åäàáâãæ]/ig,\n  alternate: 'a'\n}, {\n  regex: /[èéêë]/ig,\n  alternate: 'e'\n}, {\n  regex: /[ìíîï]/ig,\n  alternate: 'i'\n}, {\n  regex: /[òóôõö]/ig,\n  alternate: 'o'\n}, {\n  regex: /[ùúûü]/ig,\n  alternate: 'u'\n}, {\n  regex: /[æ]/ig,\n  alternate: 'ae'\n}];\n\nString.prototype.replaceCharAt = function (index, replacement) {\n  return this.substr(0, index) + replacement + this.substr(index + replacement.length);\n};\n\nvar TrieSearch = function (keyFields, options) {\n  this.options = options || {}; // Default ignoreCase to true\n\n  this.options.ignoreCase = this.options.ignoreCase === undefined ? true : this.options.ignoreCase;\n  this.options.maxCacheSize = this.options.maxCacheSize || MAX_CACHE_SIZE;\n  this.options.cache = this.options.hasOwnProperty('cache') ? this.options.cache : true;\n  this.options.splitOnRegEx = this.options.hasOwnProperty('splitOnRegEx') ? this.options.splitOnRegEx : /\\s/g;\n  this.options.splitOnGetRegEx = this.options.hasOwnProperty('splitOnGetRegEx') ? this.options.splitOnGetRegEx : this.options.splitOnRegEx;\n  this.options.min = this.options.min || 1;\n  this.options.keepAll = this.options.hasOwnProperty('keepAll') ? this.options.keepAll : false;\n  this.options.keepAllKey = this.options.hasOwnProperty('keepAllKey') ? this.options.keepAllKey : 'id';\n  this.options.idFieldOrFunction = this.options.hasOwnProperty('idFieldOrFunction') ? this.options.idFieldOrFunction : undefined;\n  this.options.expandRegexes = this.options.expandRegexes || DEFAULT_INTERNATIONALIZE_EXPAND_REGEXES;\n  this.options.insertFullUnsplitKey = this.options.hasOwnProperty('insertFullUnsplitKey') ? this.options.insertFullUnsplitKey : false;\n  this.keyFields = keyFields ? keyFields instanceof Array ? keyFields : [keyFields] : [];\n  this.root = {};\n  this.size = 0;\n\n  if (this.options.cache) {\n    this.getCache = new HashArray('key');\n  }\n};\n\nfunction deepLookup(obj, keys) {\n  return keys.length === 1 ? obj[keys[0]] : deepLookup(obj[keys[0]], keys.slice(1, keys.length));\n}\n\nTrieSearch.prototype = {\n  add: function (obj, customKeys) {\n    if (this.options.cache) this.clearCache(); // Someone might have called add via an array forEach where the second param is a number\n\n    if (typeof customKeys === 'number') {\n      customKeys = undefined;\n    }\n\n    var keyFields = customKeys || this.keyFields;\n\n    for (var k in keyFields) {\n      var key = keyFields[k],\n          isKeyArr = key instanceof Array,\n          val = isKeyArr ? deepLookup(obj, key) : obj[key];\n      if (!val) continue;\n      val = val.toString();\n      var expandedValues = this.expandString(val);\n\n      for (var v = 0; v < expandedValues.length; v++) {\n        var expandedValue = expandedValues[v];\n        this.map(expandedValue, obj);\n      }\n    }\n  },\n\n  /**\n   * By default using the options.expandRegexes, given a string like 'ö är bra', this will expand it to:\n   *\n   * ['ö är bra', 'o är bra', 'ö ar bra', 'o ar bra']\n   *\n   * By default this was built to allow for internationalization, but it could be also be expanded to\n   * allow for word alternates, etc. like spelling alternates ('teh' and 'the').\n   *\n   * This is used for insertion! This should not be used for lookup since if a person explicitly types\n   * 'ä' they probably do not want to see all results for 'a'.\n   *\n   * @param value The string to find alternates for.\n   * @returns {Array} Always returns an array even if no matches.\n   */\n  expandString: function (value) {\n    var values = [value];\n\n    if (this.options.expandRegexes && this.options.expandRegexes.length) {\n      for (var i = 0; i < this.options.expandRegexes.length; i++) {\n        var er = this.options.expandRegexes[i];\n        var match;\n\n        while ((match = er.regex.exec(value)) !== null) {\n          var alternateValue = value.replaceCharAt(match.index, er.alternate);\n          values.push(alternateValue);\n        }\n      }\n    }\n\n    return values;\n  },\n  addAll: function (arr, customKeys) {\n    for (var i = 0; i < arr.length; i++) this.add(arr[i], customKeys);\n  },\n  reset: function () {\n    this.root = {};\n    this.size = 0;\n  },\n  clearCache: function () {\n    // if (this.getCache && !this.getCache._list.length) {\n    //   return;\n    // }\n    this.getCache = new HashArray('key');\n  },\n  cleanCache: function () {\n    while (this.getCache.all.length > this.options.maxCacheSize) this.getCache.remove(this.getCache.all[0]);\n  },\n  addFromObject: function (obj, valueField) {\n    if (this.options.cache) this.clearCache();\n    valueField = valueField || 'value';\n    if (this.keyFields.indexOf('_key_') == -1) this.keyFields.push('_key_');\n\n    for (var key in obj) {\n      var o = {\n        _key_: key\n      };\n      o[valueField] = obj[key];\n      this.add(o);\n    }\n  },\n  map: function (key, value) {\n    if (this.options.splitOnRegEx && this.options.splitOnRegEx.test(key)) {\n      var phrases = key.split(this.options.splitOnRegEx);\n      var emptySplitMatch = phrases.filter(function (p) {\n        return IS_WHITESPACE.test(p);\n      });\n      var selfMatch = phrases.filter(function (p) {\n        return p === key;\n      });\n      var selfIsOnlyMatch = selfMatch.length + emptySplitMatch.length === phrases.length; // There is an edge case that a RegEx with a positive lookeahed like:\n      //  /?=[A-Z]/ // Split on capital letters for a camelcase sentence\n      // Will then match again when we call map, creating an infinite stack loop.\n\n      if (!selfIsOnlyMatch) {\n        for (var i = 0, l = phrases.length; i < l; i++) {\n          if (!IS_WHITESPACE.test(phrases[i])) {\n            this.map(phrases[i], value);\n          }\n        }\n\n        if (!this.options.insertFullUnsplitKey) {\n          return;\n        }\n      }\n    }\n\n    if (this.options.cache) this.clearCache();\n\n    if (this.options.keepAll) {\n      this.indexed = this.indexed || new HashArray([this.options.keepAllKey]);\n      this.indexed.add(value);\n    }\n\n    if (this.options.ignoreCase) {\n      key = key.toLowerCase();\n    }\n\n    var keyArr = this.keyToArr(key),\n        self = this;\n    insert(keyArr, value, this.root);\n\n    function insert(keyArr, value, node) {\n      if (keyArr.length == 0) {\n        node['value'] = node['value'] || [];\n        node['value'].push(value);\n        return;\n      }\n\n      var k = keyArr.shift();\n      if (!node[k]) self.size++;\n      node[k] = node[k] || {};\n      insert(keyArr, value, node[k]);\n    }\n  },\n  keyToArr: function (key) {\n    var keyArr;\n\n    if (this.options.min && this.options.min > 1) {\n      if (key.length < this.options.min) return [];\n      keyArr = [key.substr(0, this.options.min)];\n      keyArr = keyArr.concat(key.substr(this.options.min).split(''));\n    } else keyArr = key.split('');\n\n    return keyArr;\n  },\n  findNode: function (key) {\n    if (this.options.min > 0 && key.length < this.options.min) return [];\n    return f(this.keyToArr(key), this.root);\n\n    function f(keyArr, node) {\n      if (!node) return undefined;\n      if (keyArr.length == 0) return node;\n      var k = keyArr.shift();\n      return f(keyArr, node[k]);\n    }\n  },\n  _getCacheKey: function (phrase, limit) {\n    var cacheKey = phrase;\n\n    if (limit) {\n      cacheKey = phrase + \"_\" + limit;\n    }\n\n    return cacheKey;\n  },\n  _get: function (phrase, limit) {\n    phrase = this.options.ignoreCase ? phrase.toLowerCase() : phrase;\n    var c, node;\n    if (this.options.cache && (c = this.getCache.get(this._getCacheKey(phrase, limit)))) return c.value;\n    var ret = undefined,\n        haKeyFields = this.options.indexField ? [this.options.indexField] : this.keyFields,\n        words = this.options.splitOnGetRegEx ? phrase.split(this.options.splitOnGetRegEx) : [phrase];\n\n    for (var w = 0, l = words.length; w < l; w++) {\n      if (this.options.min && words[w].length < this.options.min) continue;\n      var temp = new HashArray(haKeyFields);\n      if (node = this.findNode(words[w])) aggregate(node, temp);\n      ret = ret ? ret.intersection(temp) : temp;\n    }\n\n    var v = ret ? ret.all : [];\n\n    if (this.options.cache) {\n      var cacheKey = this._getCacheKey(phrase, limit);\n\n      this.getCache.add({\n        key: cacheKey,\n        value: v\n      });\n      this.cleanCache();\n    }\n\n    return v;\n\n    function aggregate(node, ha) {\n      if (limit && ha.all.length === limit) {\n        return;\n      }\n\n      if (node.value && node.value.length) {\n        if (!limit || ha.all.length + node.value.length < limit) {\n          ha.addAll(node.value);\n        } else {\n          // Limit is less than the number of entries in the node.value + ha combined\n          ha.addAll(node.value.slice(0, limit - ha.all.length));\n          return;\n        }\n      }\n\n      for (var k in node) {\n        if (limit && ha.all.length === limit) {\n          return;\n        }\n\n        if (k != 'value') {\n          aggregate(node[k], ha);\n        }\n      }\n    }\n  },\n  get: function (phrases, reducer, limit) {\n    var self = this,\n        haKeyFields = this.options.indexField ? [this.options.indexField] : this.keyFields,\n        ret = undefined,\n        accumulator = undefined;\n\n    if (reducer && !this.options.idFieldOrFunction) {\n      throw new Error('To use the accumulator, you must specify and idFieldOrFunction');\n    }\n\n    phrases = phrases instanceof Array ? phrases : [phrases];\n\n    for (var i = 0, l = phrases.length; i < l; i++) {\n      var matches = this._get(phrases[i], limit);\n\n      if (reducer) {\n        accumulator = reducer(accumulator, phrases[i], matches, this);\n      } else {\n        ret = ret ? ret.addAll(matches) : new HashArray(haKeyFields).addAll(matches);\n      }\n    }\n\n    if (!reducer) {\n      return ret.all;\n    }\n\n    return accumulator;\n  },\n  getId: function (item) {\n    return typeof this.options.idFieldOrFunction === 'function' ? this.options.idFieldOrFunction(item) : item[this.options.idFieldOrFunction];\n  }\n};\n\nTrieSearch.UNION_REDUCER = function (accumulator, phrase, matches, trie) {\n  if (accumulator === undefined) {\n    return matches;\n  }\n\n  var map = {},\n      i,\n      id;\n  var maxLength = Math.max(accumulator.length, matches.length);\n  var results = [];\n  var l = 0; // One loop, O(N) for max length of accumulator or matches.\n\n  for (i = 0; i < maxLength; i++) {\n    if (i < accumulator.length) {\n      id = trie.getId(accumulator[i]);\n      map[id] = map[id] ? map[id] : 0;\n      map[id]++;\n\n      if (map[id] === 2) {\n        results[l++] = accumulator[i];\n      }\n    }\n\n    if (i < matches.length) {\n      id = trie.getId(matches[i]);\n      map[id] = map[id] ? map[id] : 0;\n      map[id]++;\n\n      if (map[id] === 2) {\n        results[l++] = matches[i];\n      }\n    }\n  }\n\n  return results;\n};\n\nmodule.exports = TrieSearch;","map":{"version":3,"sources":["/Users/jasmineharris/Desktop/Elite/woto/node_modules/trie-search/src/TrieSearch.js"],"names":["HashArray","require","MAX_CACHE_SIZE","IS_WHITESPACE","DEFAULT_INTERNATIONALIZE_EXPAND_REGEXES","regex","alternate","String","prototype","replaceCharAt","index","replacement","substr","length","TrieSearch","keyFields","options","ignoreCase","undefined","maxCacheSize","cache","hasOwnProperty","splitOnRegEx","splitOnGetRegEx","min","keepAll","keepAllKey","idFieldOrFunction","expandRegexes","insertFullUnsplitKey","Array","root","size","getCache","deepLookup","obj","keys","slice","add","customKeys","clearCache","k","key","isKeyArr","val","toString","expandedValues","expandString","v","expandedValue","map","value","values","i","er","match","exec","alternateValue","push","addAll","arr","reset","cleanCache","all","remove","addFromObject","valueField","indexOf","o","_key_","test","phrases","split","emptySplitMatch","filter","p","selfMatch","selfIsOnlyMatch","l","indexed","toLowerCase","keyArr","keyToArr","self","insert","node","shift","concat","findNode","f","_getCacheKey","phrase","limit","cacheKey","_get","c","get","ret","haKeyFields","indexField","words","w","temp","aggregate","intersection","ha","reducer","accumulator","Error","matches","getId","item","UNION_REDUCER","trie","id","maxLength","Math","max","results","module","exports"],"mappings":"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","sourcesContent":["var HashArray = require('hasharray');\n\nvar MAX_CACHE_SIZE = 64;\n\nvar IS_WHITESPACE = /^[\\s]*$/;\n\nvar DEFAULT_INTERNATIONALIZE_EXPAND_REGEXES = [\n  {\n    regex: /[åäàáâãæ]/ig,\n    alternate: 'a'\n  },\n  {\n    regex: /[èéêë]/ig,\n    alternate: 'e'\n  },\n  {\n    regex: /[ìíîï]/ig,\n    alternate: 'i'\n  },\n  {\n    regex: /[òóôõö]/ig,\n    alternate: 'o'\n  },\n  {\n    regex: /[ùúûü]/ig,\n    alternate: 'u'\n  },\n  {\n    regex: /[æ]/ig,\n    alternate: 'ae'\n  }\n];\n\nString.prototype.replaceCharAt=function(index, replacement) {\n  return this.substr(0, index) + replacement + this.substr(index + replacement.length);\n};\n\nvar TrieSearch = function (keyFields, options) {\n  this.options = options || {};\n\n  // Default ignoreCase to true\n  this.options.ignoreCase = (this.options.ignoreCase === undefined) ? true : this.options.ignoreCase;\n  this.options.maxCacheSize = this.options.maxCacheSize || MAX_CACHE_SIZE;\n  this.options.cache = this.options.hasOwnProperty('cache') ? this.options.cache : true;\n  this.options.splitOnRegEx = this.options.hasOwnProperty('splitOnRegEx') ? this.options.splitOnRegEx : /\\s/g;\n  this.options.splitOnGetRegEx = this.options.hasOwnProperty('splitOnGetRegEx') ? this.options.splitOnGetRegEx : this.options.splitOnRegEx;\n  this.options.min = this.options.min || 1;\n  this.options.keepAll = this.options.hasOwnProperty('keepAll') ? this.options.keepAll : false;\n  this.options.keepAllKey = this.options.hasOwnProperty('keepAllKey') ? this.options.keepAllKey : 'id';\n  this.options.idFieldOrFunction = this.options.hasOwnProperty('idFieldOrFunction') ? this.options.idFieldOrFunction : undefined;\n  this.options.expandRegexes = this.options.expandRegexes || DEFAULT_INTERNATIONALIZE_EXPAND_REGEXES;\n  this.options.insertFullUnsplitKey = this.options.hasOwnProperty('insertFullUnsplitKey') ? this.options.insertFullUnsplitKey : false;\n\n  this.keyFields = keyFields ? (keyFields instanceof Array ? keyFields : [keyFields]) : [];\n  this.root = {};\n  this.size = 0;\n\n  if (this.options.cache) {\n    this.getCache = new HashArray('key');\n  }\n};\n\nfunction deepLookup(obj, keys) {\n  return keys.length === 1 ? obj[keys[0]] : deepLookup(obj[keys[0]], keys.slice(1, keys.length));\n}\n\nTrieSearch.prototype = {\n  add: function (obj, customKeys) {\n    if (this.options.cache)\n      this.clearCache();\n\n    // Someone might have called add via an array forEach where the second param is a number\n    if (typeof customKeys === 'number') {\n      customKeys = undefined;\n    }\n\n    var keyFields = customKeys || this.keyFields;\n\n    for (var k in keyFields)\n    {\n      var key = keyFields[k],\n        isKeyArr = key instanceof Array,\n        val = isKeyArr ? deepLookup(obj, key) : obj[key];\n\n      if (!val) continue;\n\n      val = val.toString();\n\n      var expandedValues = this.expandString(val);\n\n      for (var v = 0; v < expandedValues.length; v++) {\n        var expandedValue = expandedValues[v];\n\n        this.map(expandedValue, obj);\n      }\n    }\n  },\n  /**\n   * By default using the options.expandRegexes, given a string like 'ö är bra', this will expand it to:\n   *\n   * ['ö är bra', 'o är bra', 'ö ar bra', 'o ar bra']\n   *\n   * By default this was built to allow for internationalization, but it could be also be expanded to\n   * allow for word alternates, etc. like spelling alternates ('teh' and 'the').\n   *\n   * This is used for insertion! This should not be used for lookup since if a person explicitly types\n   * 'ä' they probably do not want to see all results for 'a'.\n   *\n   * @param value The string to find alternates for.\n   * @returns {Array} Always returns an array even if no matches.\n   */\n  expandString: function(value) {\n    var values = [value];\n\n    if (this.options.expandRegexes && this.options.expandRegexes.length) {\n      for (var i = 0; i < this.options.expandRegexes.length; i++) {\n        var er = this.options.expandRegexes[i];\n        var match;\n\n        while((match = er.regex.exec(value)) !== null) {\n          var alternateValue = value.replaceCharAt(match.index, er.alternate);\n          values.push(alternateValue);\n        }\n      }\n    }\n\n    return values;\n  },\n  addAll: function (arr, customKeys) {\n    for (var i = 0; i < arr.length; i++)\n      this.add(arr[i], customKeys);\n  },\n  reset: function () {\n    this.root = {};\n    this.size = 0;\n  },\n  clearCache: function () {\n    // if (this.getCache && !this.getCache._list.length) {\n    //   return;\n    // }\n    this.getCache = new HashArray('key');\n  },\n  cleanCache: function () {\n    while (this.getCache.all.length > this.options.maxCacheSize)\n      this.getCache.remove(this.getCache.all[0]);\n  },\n  addFromObject: function (obj, valueField) {\n    if (this.options.cache)\n      this.clearCache();\n\n    valueField = valueField || 'value';\n\n    if (this.keyFields.indexOf('_key_') == -1)\n      this.keyFields.push('_key_');\n\n    for (var key in obj)\n    {\n      var o = {_key_: key};\n      o[valueField] = obj[key];\n      this.add(o);\n    }\n  },\n  map: function (key, value) {\n    if (this.options.splitOnRegEx && this.options.splitOnRegEx.test(key))\n    {\n      var phrases = key.split(this.options.splitOnRegEx);\n      var emptySplitMatch = phrases.filter(function(p) { return IS_WHITESPACE.test(p); });\n      var selfMatch = phrases.filter(function(p) { return p === key; });\n      var selfIsOnlyMatch = selfMatch.length + emptySplitMatch.length === phrases.length;\n\n      // There is an edge case that a RegEx with a positive lookeahed like:\n      //  /?=[A-Z]/ // Split on capital letters for a camelcase sentence\n      // Will then match again when we call map, creating an infinite stack loop.\n      if (!selfIsOnlyMatch) {\n        for (var i = 0, l = phrases.length; i < l; i++) {\n          if (!IS_WHITESPACE.test(phrases[i])) {\n            this.map(phrases[i], value);\n          }\n        }\n\n        if (!this.options.insertFullUnsplitKey) {\n          return;\n        }\n      }\n    }\n\n    if (this.options.cache)\n      this.clearCache();\n\n    if (this.options.keepAll) {\n      this.indexed = this.indexed || new HashArray([this.options.keepAllKey]);\n      this.indexed.add(value);\n    }\n\n    if (this.options.ignoreCase) {\n      key = key.toLowerCase();\n    }\n\n    var keyArr = this.keyToArr(key),\n      self = this;\n\n    insert(keyArr, value, this.root);\n\n    function insert(keyArr, value, node) {\n      if (keyArr.length == 0)\n      {\n        node['value'] = node['value'] || [];\n        node['value'].push(value);\n        return; \n      }\n\n      var k = keyArr.shift();\n\n      if (!node[k])\n        self.size++;\n\n      node[k] = node[k] || {};\n\n      insert(keyArr, value, node[k])\n    }\n  },\n  keyToArr: function (key) {\n    var keyArr;\n      \n    if (this.options.min && this.options.min > 1)\n    {\n      if (key.length < this.options.min)\n        return [];\n\n      keyArr = [key.substr(0, this.options.min)];\n      keyArr = keyArr.concat(key.substr(this.options.min).split(''));\n    }\n    else keyArr = key.split('');\n\n    return keyArr;\n  },\n  findNode: function (key) {\n    if (this.options.min > 0 && key.length < this.options.min)\n      return [];\n\n    return f(this.keyToArr(key), this.root);\n\n    function f(keyArr, node) {\n      if (!node) return undefined;\n      if (keyArr.length == 0) return node;\n\n      var k = keyArr.shift();\n      return f(keyArr, node[k]);\n    }\n  },\n  _getCacheKey: function(phrase, limit){\n    var cacheKey = phrase\n    if(limit) {\n      cacheKey = phrase + \"_\" + limit\n    }\n    return cacheKey\n  },\n  _get: function (phrase, limit) {\n    phrase = this.options.ignoreCase ? phrase.toLowerCase() : phrase;\n    \n    var c, node;\n    if (this.options.cache && (c = this.getCache.get(this._getCacheKey(phrase, limit))))\n      return c.value;\n\n    var ret = undefined,\n      haKeyFields = this.options.indexField ? [this.options.indexField] : this.keyFields,\n      words = this.options.splitOnGetRegEx ? phrase.split(this.options.splitOnGetRegEx) : [phrase];\n\n    for (var w = 0, l = words.length; w < l; w++)\n    {\n      if (this.options.min && words[w].length < this.options.min)\n        continue;\n\n      var temp = new HashArray(haKeyFields);\n\n      if (node = this.findNode(words[w]))\n        aggregate(node, temp);\n\n      ret = ret ? ret.intersection(temp) : temp;\n    }\n    \n    var v = ret ? ret.all : [];\n\n    if (this.options.cache)\n    {\n      var cacheKey = this._getCacheKey(phrase, limit)\n      this.getCache.add({key: cacheKey, value: v});\n      this.cleanCache();\n    }\n\n    return v;\n    \n    function aggregate(node, ha) {\n      if(limit && ha.all.length === limit) {\n        return\n      }\n\n      if (node.value && node.value.length) {\n        if(!limit || (ha.all.length + node.value.length) < limit) {\n          ha.addAll(node.value);\n        } else {\n          // Limit is less than the number of entries in the node.value + ha combined\n          ha.addAll(node.value.slice(0, limit - ha.all.length))\n          return\n        }\n      }\n\n      for (var k in node) {\n        if (limit && ha.all.length === limit){\n          return\n        }\n        if (k != 'value') {\n          aggregate(node[k], ha);\n        }\n      }\n    }\n  },\n  get: function (phrases, reducer, limit) {\n    var self = this,\n      haKeyFields = this.options.indexField ? [this.options.indexField] : this.keyFields,\n      ret = undefined,\n      accumulator = undefined;\n\n    if (reducer && !this.options.idFieldOrFunction) {\n      throw new Error('To use the accumulator, you must specify and idFieldOrFunction');\n    }\n\n    phrases = (phrases instanceof Array) ? phrases : [phrases];\n\n    for (var i = 0, l = phrases.length; i < l; i++)\n    {\n      var matches = this._get(phrases[i], limit);\n\n      if (reducer) {\n        accumulator = reducer(accumulator, phrases[i], matches, this);\n      } else {\n        ret = ret ? ret.addAll(matches) : new HashArray(haKeyFields).addAll(matches);\n      }\n    }\n\n    if (!reducer) {\n      return ret.all;\n    }\n\n    return accumulator;\n  },\n  getId: function (item) {\n    return typeof this.options.idFieldOrFunction === 'function' ? this.options.idFieldOrFunction(item) : item[this.options.idFieldOrFunction];\n  }\n};\n\nTrieSearch.UNION_REDUCER = function(accumulator, phrase, matches, trie) {\n  if (accumulator === undefined) {\n    return matches;\n  }\n\n  var map = {}, i, id;\n  var maxLength = Math.max(accumulator.length, matches.length);\n  var results = [];\n  var l = 0;\n\n  // One loop, O(N) for max length of accumulator or matches.\n  for (i = 0; i < maxLength; i++) {\n    if (i < accumulator.length) {\n      id = trie.getId(accumulator[i]);\n      map[id] = map[id] ? map[id] : 0;\n      map[id]++;\n\n      if (map[id] === 2) {\n        results[l++] = accumulator[i];\n      }\n    }\n\n    if (i < matches.length) {\n      id = trie.getId(matches[i]);\n      map[id] = map[id] ? map[id] : 0;\n      map[id]++;\n\n      if (map[id] === 2) {\n        results[l++] = matches[i];\n      }\n    }\n  }\n\n  return results;\n};\n\nmodule.exports = TrieSearch;\n"]},"metadata":{},"sourceType":"script"}