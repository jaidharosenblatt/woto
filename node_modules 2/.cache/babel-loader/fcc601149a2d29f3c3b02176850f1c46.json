{"ast":null,"code":"import actionTypes from \"./actionTypes\";\nimport API from \"../../api/API\";\nimport { startLoading, stopLoading, clearError, setError, setServerError, setSuccessMessage, resetRosterStatus, setServerSuccessMessage, setCustomServerError } from \"../status/actionCreators\";\nimport { setCurrentCourse, changeCourse } from \"../current-course/actionCreators\";\nimport { setCourse } from \"../courses/actions/actionCreators\";\nimport selectors from \"../selectors\";\n/**\n * Create a dispatch to load sorted courses in redux\n * @param {Array} courses\n * @returns {Object} function to dispatch\n */\n\nexport const setSortedCourses = courses => {\n  return {\n    type: actionTypes.SET_SORTED_COURSES,\n    payload: courses\n  };\n};\n/**\n * Create a dispatch to change a given course in redux\n * @param {Object} course\n * @returns {Object} function to dispatch\n */\n\nexport const updateCourse = course => {\n  return {\n    type: actionTypes.UPDATE_COURSE,\n    payload: course\n  };\n};\n/**\n * @function createCourse\n * Create a new course and add it to sortedCourses in redux\n * @param {Object} course to add\n * @returns {Function} redux thunk action\n */\n\nexport const createCourse = course => async dispatch => {\n  dispatch(startLoading());\n  let newCourse;\n\n  try {\n    newCourse = await API.postCourses(course); // set in sorted courses\n\n    dispatch({\n      type: actionTypes.ADD_COURSE,\n      payload: newCourse\n    }); // reset from prev roster status\n\n    dispatch(resetRosterStatus()); // set in loaded courses\n\n    dispatch(setCourse(newCourse._id, newCourse)); // set to active course\n\n    dispatch(setCurrentCourse(newCourse._id));\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"creating your course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n\n  return newCourse;\n};\n/**\n * @function courseUnenroll\n * Unenroll from a course and remove it from sortedCourses in redux\n * @param {Object} course to remove\n * @returns {Function} redux thunk action\n */\n\nexport const courseUnenroll = course => async dispatch => {\n  dispatch(startLoading());\n\n  try {\n    await API.unenroll(course._id);\n    dispatch({\n      type: actionTypes.REMOVE_COURSE,\n      payload: course._id\n    });\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"un-enrolling from this course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * @function courseArchive\n * Archive a course and remove it from sortedCourses in redux\n * @param {Object} course\n * @returns {Function} redux thunk action\n */\n\nexport const courseArchive = course => async dispatch => {\n  dispatch(startLoading());\n\n  try {\n    await API.editCourse(course._id, {\n      archived: true\n    });\n    dispatch({\n      type: actionTypes.REMOVE_COURSE,\n      payload: course._id\n    });\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"archiving this course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * @function courseUnarchive\n * Unarchive a course and add it back to sortedCourses in redux\n * @param {Object} course\n * @returns {Function} redux thunk action\n */\n\nexport const courseUnarchive = course => async dispatch => {\n  dispatch(startLoading());\n\n  try {\n    await API.editCourse(course._id, {\n      archived: false\n    });\n    dispatch({\n      type: actionTypes.ADD_COURSE,\n      payload: course\n    });\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"archiving this course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * @function courseEnroll\n * Enroll in a new course and add it to sortedCourses in redux\n * @param {String} accessKey\n * @returns {Function} redux thunk action\n */\n\nexport const courseEnroll = accessKey => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    const newCourse = await API.courseEnroll({\n      accessKey\n    }); // add course to redux/courses\n\n    dispatch(setCourse(newCourse._id, newCourse)); // set course as current course and load session, discussions, etc\n\n    await dispatch(changeCourse(newCourse._id)); // add to navbar\n\n    dispatch({\n      type: actionTypes.ADD_COURSE,\n      payload: newCourse\n    });\n    dispatch(setSuccessMessage(`Enrolled in new course, ${newCourse === null || newCourse === void 0 ? void 0 : newCourse.code}`));\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(\"Invalid course code. Please contact your instructor\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * @function editCourse\n * Edit a course and update it in sortedCourses and courses\n * @param {Object} changes from ant form\n * @returns {Function} redux thunk action\n */\n\nexport const editCourse = changes => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n\n  try {\n    const course = await API.editCourse(courseID, changes); // updated in sortedCourses\n\n    dispatch(updateCourse(course)); // update in courses\n\n    dispatch(setCourse(courseID, course));\n    dispatch(setServerSuccessMessage(course.code + \" updated\"));\n  } catch (error) {\n    dispatch(setCustomServerError(\"Error updating course\"));\n  }\n};\n/**\n * @function sortCourses\n * Sort courses first by if they have a session then by code\n * Then return courses that only contain id, code, session, and name\n * @param {Array} courses\n * @returns {Array} courses sorted and truncated\n */\n\nexport function sortCourses(courses) {\n  const filtered = courses.filter(course => !course.archived);\n  filtered.sort((a, b) => {\n    if (a.activeSession && b.activeSession || !a.activeSession && !b.activeSession) {\n      return b.code > a.code ? 1 : -1;\n    } else if (a.activeSession) {\n      return -1;\n    } else {\n      return 1;\n    }\n  });\n  return filtered;\n}\n/**\n * Reset the sortedCourses state in redux\n * @returns {Object} to dispatch to redux\n */\n\nexport function resetSortedCourses() {\n  return {\n    type: actionTypes.RESET\n  };\n}","map":{"version":3,"sources":["/Users/jasmineharris/Desktop/Elite/woto/src/redux/sorted-courses/actionCreators.js"],"names":["actionTypes","API","startLoading","stopLoading","clearError","setError","setServerError","setSuccessMessage","resetRosterStatus","setServerSuccessMessage","setCustomServerError","setCurrentCourse","changeCourse","setCourse","selectors","setSortedCourses","courses","type","SET_SORTED_COURSES","payload","updateCourse","course","UPDATE_COURSE","createCourse","dispatch","newCourse","postCourses","ADD_COURSE","_id","error","courseUnenroll","unenroll","REMOVE_COURSE","courseArchive","editCourse","archived","courseUnarchive","courseEnroll","accessKey","getState","code","console","changes","courseID","getCourseID","sortCourses","filtered","filter","sort","a","b","activeSession","resetSortedCourses","RESET"],"mappings":"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","sourcesContent":["import actionTypes from \"./actionTypes\";\nimport API from \"../../api/API\";\n\nimport {\n  startLoading,\n  stopLoading,\n  clearError,\n  setError,\n  setServerError,\n  setSuccessMessage,\n  resetRosterStatus,\n  setServerSuccessMessage,\n  setCustomServerError,\n} from \"../status/actionCreators\";\nimport {\n  setCurrentCourse,\n  changeCourse,\n} from \"../current-course/actionCreators\";\nimport { setCourse } from \"../courses/actions/actionCreators\";\nimport selectors from \"../selectors\";\n\n/**\n * Create a dispatch to load sorted courses in redux\n * @param {Array} courses\n * @returns {Object} function to dispatch\n */\nexport const setSortedCourses = (courses) => {\n  return {\n    type: actionTypes.SET_SORTED_COURSES,\n    payload: courses,\n  };\n};\n\n/**\n * Create a dispatch to change a given course in redux\n * @param {Object} course\n * @returns {Object} function to dispatch\n */\nexport const updateCourse = (course) => {\n  return {\n    type: actionTypes.UPDATE_COURSE,\n    payload: course,\n  };\n};\n\n/**\n * @function createCourse\n * Create a new course and add it to sortedCourses in redux\n * @param {Object} course to add\n * @returns {Function} redux thunk action\n */\nexport const createCourse = (course) => async (dispatch) => {\n  dispatch(startLoading());\n  let newCourse;\n  try {\n    newCourse = await API.postCourses(course);\n    // set in sorted courses\n    dispatch({\n      type: actionTypes.ADD_COURSE,\n      payload: newCourse,\n    });\n\n    // reset from prev roster status\n    dispatch(resetRosterStatus());\n\n    // set in loaded courses\n    dispatch(setCourse(newCourse._id, newCourse));\n\n    // set to active course\n    dispatch(setCurrentCourse(newCourse._id));\n\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"creating your course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n  return newCourse;\n};\n\n/**\n * @function courseUnenroll\n * Unenroll from a course and remove it from sortedCourses in redux\n * @param {Object} course to remove\n * @returns {Function} redux thunk action\n */\nexport const courseUnenroll = (course) => async (dispatch) => {\n  dispatch(startLoading());\n  try {\n    await API.unenroll(course._id);\n    dispatch({\n      type: actionTypes.REMOVE_COURSE,\n      payload: course._id,\n    });\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"un-enrolling from this course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * @function courseArchive\n * Archive a course and remove it from sortedCourses in redux\n * @param {Object} course\n * @returns {Function} redux thunk action\n */\nexport const courseArchive = (course) => async (dispatch) => {\n  dispatch(startLoading());\n  try {\n    await API.editCourse(course._id, { archived: true });\n    dispatch({\n      type: actionTypes.REMOVE_COURSE,\n      payload: course._id,\n    });\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"archiving this course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * @function courseUnarchive\n * Unarchive a course and add it back to sortedCourses in redux\n * @param {Object} course\n * @returns {Function} redux thunk action\n */\nexport const courseUnarchive = (course) => async (dispatch) => {\n  dispatch(startLoading());\n  try {\n    await API.editCourse(course._id, { archived: false });\n    dispatch({\n      type: actionTypes.ADD_COURSE,\n      payload: course,\n    });\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"archiving this course\"));\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * @function courseEnroll\n * Enroll in a new course and add it to sortedCourses in redux\n * @param {String} accessKey\n * @returns {Function} redux thunk action\n */\nexport const courseEnroll = (accessKey) => async (dispatch, getState) => {\n  dispatch(startLoading());\n  try {\n    const newCourse = await API.courseEnroll({ accessKey });\n\n    // add course to redux/courses\n    dispatch(setCourse(newCourse._id, newCourse));\n\n    // set course as current course and load session, discussions, etc\n    await dispatch(changeCourse(newCourse._id));\n\n    // add to navbar\n    dispatch({\n      type: actionTypes.ADD_COURSE,\n      payload: newCourse,\n    });\n\n    dispatch(setSuccessMessage(`Enrolled in new course, ${newCourse?.code}`));\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(\"Invalid course code. Please contact your instructor\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * @function editCourse\n * Edit a course and update it in sortedCourses and courses\n * @param {Object} changes from ant form\n * @returns {Function} redux thunk action\n */\nexport const editCourse = (changes) => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  try {\n    const course = await API.editCourse(courseID, changes);\n    // updated in sortedCourses\n    dispatch(updateCourse(course));\n    // update in courses\n    dispatch(setCourse(courseID, course));\n    dispatch(setServerSuccessMessage(course.code + \" updated\"));\n  } catch (error) {\n    dispatch(setCustomServerError(\"Error updating course\"));\n  }\n};\n\n/**\n * @function sortCourses\n * Sort courses first by if they have a session then by code\n * Then return courses that only contain id, code, session, and name\n * @param {Array} courses\n * @returns {Array} courses sorted and truncated\n */\nexport function sortCourses(courses) {\n  const filtered = courses.filter((course) => !course.archived);\n  filtered.sort((a, b) => {\n    if (\n      (a.activeSession && b.activeSession) ||\n      (!a.activeSession && !b.activeSession)\n    ) {\n      return b.code > a.code ? 1 : -1;\n    } else if (a.activeSession) {\n      return -1;\n    } else {\n      return 1;\n    }\n  });\n  return filtered;\n}\n\n/**\n * Reset the sortedCourses state in redux\n * @returns {Object} to dispatch to redux\n */\nexport function resetSortedCourses() {\n  return {\n    type: actionTypes.RESET,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}