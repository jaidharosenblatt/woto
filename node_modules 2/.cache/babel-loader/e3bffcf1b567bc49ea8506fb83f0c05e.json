{"ast":null,"code":"// Generated by CoffeeScript 1.10.0\nvar BRUTEFORCE_CARDINALITY, MIN_GUESSES_BEFORE_GROWING_SEQUENCE, MIN_SUBMATCH_GUESSES_MULTI_CHAR, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, adjacency_graphs, calc_average_degree, k, scoring, v;\nadjacency_graphs = require('./adjacency_graphs');\n\ncalc_average_degree = function (graph) {\n  var average, k, key, n, neighbors, v;\n  average = 0;\n\n  for (key in graph) {\n    neighbors = graph[key];\n\n    average += function () {\n      var len, o, results;\n      results = [];\n\n      for (o = 0, len = neighbors.length; o < len; o++) {\n        n = neighbors[o];\n\n        if (n) {\n          results.push(n);\n        }\n      }\n\n      return results;\n    }().length;\n  }\n\n  average /= function () {\n    var results;\n    results = [];\n\n    for (k in graph) {\n      v = graph[k];\n      results.push(k);\n    }\n\n    return results;\n  }().length;\n\n  return average;\n};\n\nBRUTEFORCE_CARDINALITY = 10;\nMIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\nMIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\nMIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\nscoring = {\n  nCk: function (n, k) {\n    var d, o, r, ref;\n\n    if (k > n) {\n      return 0;\n    }\n\n    if (k === 0) {\n      return 1;\n    }\n\n    r = 1;\n\n    for (d = o = 1, ref = k; 1 <= ref ? o <= ref : o >= ref; d = 1 <= ref ? ++o : --o) {\n      r *= n;\n      r /= d;\n      n -= 1;\n    }\n\n    return r;\n  },\n  log10: function (n) {\n    return Math.log(n) / Math.log(10);\n  },\n  log2: function (n) {\n    return Math.log(n) / Math.log(2);\n  },\n  factorial: function (n) {\n    var f, i, o, ref;\n\n    if (n < 2) {\n      return 1;\n    }\n\n    f = 1;\n\n    for (i = o = 2, ref = n; 2 <= ref ? o <= ref : o >= ref; i = 2 <= ref ? ++o : --o) {\n      f *= i;\n    }\n\n    return f;\n  },\n  most_guessable_match_sequence: function (password, matches, _exclude_additive) {\n    var _, bruteforce_update, guesses, k, l, len, len1, len2, lst, m, make_bruteforce_match, matches_by_j, n, o, optimal, optimal_l, optimal_match_sequence, q, ref, ref1, u, unwind, update, w;\n\n    if (_exclude_additive == null) {\n      _exclude_additive = false;\n    }\n\n    n = password.length;\n\n    matches_by_j = function () {\n      var o, ref, results;\n      results = [];\n\n      for (_ = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; _ = 0 <= ref ? ++o : --o) {\n        results.push([]);\n      }\n\n      return results;\n    }();\n\n    for (o = 0, len = matches.length; o < len; o++) {\n      m = matches[o];\n      matches_by_j[m.j].push(m);\n    }\n\n    for (q = 0, len1 = matches_by_j.length; q < len1; q++) {\n      lst = matches_by_j[q];\n      lst.sort(function (m1, m2) {\n        return m1.i - m2.i;\n      });\n    }\n\n    optimal = {\n      m: function () {\n        var ref, results, u;\n        results = [];\n\n        for (_ = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; _ = 0 <= ref ? ++u : --u) {\n          results.push({});\n        }\n\n        return results;\n      }(),\n      pi: function () {\n        var ref, results, u;\n        results = [];\n\n        for (_ = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; _ = 0 <= ref ? ++u : --u) {\n          results.push({});\n        }\n\n        return results;\n      }(),\n      g: function () {\n        var ref, results, u;\n        results = [];\n\n        for (_ = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; _ = 0 <= ref ? ++u : --u) {\n          results.push({});\n        }\n\n        return results;\n      }()\n    };\n\n    update = function (_this) {\n      return function (m, l) {\n        var competing_g, competing_l, g, k, pi, ref;\n        k = m.j;\n        pi = _this.estimate_guesses(m, password);\n\n        if (l > 1) {\n          pi *= optimal.pi[m.i - 1][l - 1];\n        }\n\n        g = _this.factorial(l) * pi;\n\n        if (!_exclude_additive) {\n          g += Math.pow(MIN_GUESSES_BEFORE_GROWING_SEQUENCE, l - 1);\n        }\n\n        ref = optimal.g[k];\n\n        for (competing_l in ref) {\n          competing_g = ref[competing_l];\n\n          if (competing_l > l) {\n            continue;\n          }\n\n          if (competing_g <= g) {\n            return;\n          }\n        }\n\n        optimal.g[k][l] = g;\n        optimal.m[k][l] = m;\n        return optimal.pi[k][l] = pi;\n      };\n    }(this);\n\n    bruteforce_update = function (_this) {\n      return function (k) {\n        var i, l, last_m, ref, results, u;\n        m = make_bruteforce_match(0, k);\n        update(m, 1);\n        results = [];\n\n        for (i = u = 1, ref = k; 1 <= ref ? u <= ref : u >= ref; i = 1 <= ref ? ++u : --u) {\n          m = make_bruteforce_match(i, k);\n          results.push(function () {\n            var ref1, results1;\n            ref1 = optimal.m[i - 1];\n            results1 = [];\n\n            for (l in ref1) {\n              last_m = ref1[l];\n              l = parseInt(l);\n\n              if (last_m.pattern === 'bruteforce') {\n                continue;\n              }\n\n              results1.push(update(m, l + 1));\n            }\n\n            return results1;\n          }());\n        }\n\n        return results;\n      };\n    }(this);\n\n    make_bruteforce_match = function (_this) {\n      return function (i, j) {\n        return {\n          pattern: 'bruteforce',\n          token: password.slice(i, +j + 1 || 9e9),\n          i: i,\n          j: j\n        };\n      };\n    }(this);\n\n    unwind = function (_this) {\n      return function (n) {\n        var candidate_g, candidate_l, g, k, l, optimal_match_sequence, ref;\n        optimal_match_sequence = [];\n        k = n - 1;\n        l = void 0;\n        g = Infinity;\n        ref = optimal.g[k];\n\n        for (candidate_l in ref) {\n          candidate_g = ref[candidate_l];\n\n          if (candidate_g < g) {\n            l = candidate_l;\n            g = candidate_g;\n          }\n        }\n\n        while (k >= 0) {\n          m = optimal.m[k][l];\n          optimal_match_sequence.unshift(m);\n          k = m.i - 1;\n          l--;\n        }\n\n        return optimal_match_sequence;\n      };\n    }(this);\n\n    for (k = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; k = 0 <= ref ? ++u : --u) {\n      ref1 = matches_by_j[k];\n\n      for (w = 0, len2 = ref1.length; w < len2; w++) {\n        m = ref1[w];\n\n        if (m.i > 0) {\n          for (l in optimal.m[m.i - 1]) {\n            l = parseInt(l);\n            update(m, l + 1);\n          }\n        } else {\n          update(m, 1);\n        }\n      }\n\n      bruteforce_update(k);\n    }\n\n    optimal_match_sequence = unwind(n);\n    optimal_l = optimal_match_sequence.length;\n\n    if (password.length === 0) {\n      guesses = 1;\n    } else {\n      guesses = optimal.g[n - 1][optimal_l];\n    }\n\n    return {\n      password: password,\n      guesses: guesses,\n      guesses_log10: this.log10(guesses),\n      sequence: optimal_match_sequence\n    };\n  },\n  estimate_guesses: function (match, password) {\n    var estimation_functions, guesses, min_guesses;\n\n    if (match.guesses != null) {\n      return match.guesses;\n    }\n\n    min_guesses = 1;\n\n    if (match.token.length < password.length) {\n      min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR : MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n    }\n\n    estimation_functions = {\n      bruteforce: this.bruteforce_guesses,\n      dictionary: this.dictionary_guesses,\n      spatial: this.spatial_guesses,\n      repeat: this.repeat_guesses,\n      sequence: this.sequence_guesses,\n      regex: this.regex_guesses,\n      date: this.date_guesses\n    };\n    guesses = estimation_functions[match.pattern].call(this, match);\n    match.guesses = Math.max(guesses, min_guesses);\n    match.guesses_log10 = this.log10(match.guesses);\n    return match.guesses;\n  },\n  bruteforce_guesses: function (match) {\n    var guesses, min_guesses;\n    guesses = Math.pow(BRUTEFORCE_CARDINALITY, match.token.length);\n\n    if (guesses === Number.POSITIVE_INFINITY) {\n      guesses = Number.MAX_VALUE;\n    }\n\n    min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1 : MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n    return Math.max(guesses, min_guesses);\n  },\n  repeat_guesses: function (match) {\n    return match.base_guesses * match.repeat_count;\n  },\n  sequence_guesses: function (match) {\n    var base_guesses, first_chr;\n    first_chr = match.token.charAt(0);\n\n    if (first_chr === 'a' || first_chr === 'A' || first_chr === 'z' || first_chr === 'Z' || first_chr === '0' || first_chr === '1' || first_chr === '9') {\n      base_guesses = 4;\n    } else {\n      if (first_chr.match(/\\d/)) {\n        base_guesses = 10;\n      } else {\n        base_guesses = 26;\n      }\n    }\n\n    if (!match.ascending) {\n      base_guesses *= 2;\n    }\n\n    return base_guesses * match.token.length;\n  },\n  MIN_YEAR_SPACE: 20,\n  REFERENCE_YEAR: new Date().getFullYear(),\n  regex_guesses: function (match) {\n    var char_class_bases, year_space;\n    char_class_bases = {\n      alpha_lower: 26,\n      alpha_upper: 26,\n      alpha: 52,\n      alphanumeric: 62,\n      digits: 10,\n      symbols: 33\n    };\n\n    if (match.regex_name in char_class_bases) {\n      return Math.pow(char_class_bases[match.regex_name], match.token.length);\n    } else {\n      switch (match.regex_name) {\n        case 'recent_year':\n          year_space = Math.abs(parseInt(match.regex_match[0]) - this.REFERENCE_YEAR);\n          year_space = Math.max(year_space, this.MIN_YEAR_SPACE);\n          return year_space;\n      }\n    }\n  },\n  date_guesses: function (match) {\n    var guesses, year_space;\n    year_space = Math.max(Math.abs(match.year - this.REFERENCE_YEAR), this.MIN_YEAR_SPACE);\n    guesses = year_space * 365;\n\n    if (match.separator) {\n      guesses *= 4;\n    }\n\n    return guesses;\n  },\n  KEYBOARD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.qwerty),\n  KEYPAD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.keypad),\n  KEYBOARD_STARTING_POSITIONS: function () {\n    var ref, results;\n    ref = adjacency_graphs.qwerty;\n    results = [];\n\n    for (k in ref) {\n      v = ref[k];\n      results.push(k);\n    }\n\n    return results;\n  }().length,\n  KEYPAD_STARTING_POSITIONS: function () {\n    var ref, results;\n    ref = adjacency_graphs.keypad;\n    results = [];\n\n    for (k in ref) {\n      v = ref[k];\n      results.push(k);\n    }\n\n    return results;\n  }().length,\n  spatial_guesses: function (match) {\n    var L, S, U, d, guesses, i, j, o, possible_turns, q, ref, ref1, ref2, ref3, s, shifted_variations, t, u;\n\n    if ((ref = match.graph) === 'qwerty' || ref === 'dvorak') {\n      s = this.KEYBOARD_STARTING_POSITIONS;\n      d = this.KEYBOARD_AVERAGE_DEGREE;\n    } else {\n      s = this.KEYPAD_STARTING_POSITIONS;\n      d = this.KEYPAD_AVERAGE_DEGREE;\n    }\n\n    guesses = 0;\n    L = match.token.length;\n    t = match.turns;\n\n    for (i = o = 2, ref1 = L; 2 <= ref1 ? o <= ref1 : o >= ref1; i = 2 <= ref1 ? ++o : --o) {\n      possible_turns = Math.min(t, i - 1);\n\n      for (j = q = 1, ref2 = possible_turns; 1 <= ref2 ? q <= ref2 : q >= ref2; j = 1 <= ref2 ? ++q : --q) {\n        guesses += this.nCk(i - 1, j - 1) * s * Math.pow(d, j);\n      }\n    }\n\n    if (match.shifted_count) {\n      S = match.shifted_count;\n      U = match.token.length - match.shifted_count;\n\n      if (S === 0 || U === 0) {\n        guesses *= 2;\n      } else {\n        shifted_variations = 0;\n\n        for (i = u = 1, ref3 = Math.min(S, U); 1 <= ref3 ? u <= ref3 : u >= ref3; i = 1 <= ref3 ? ++u : --u) {\n          shifted_variations += this.nCk(S + U, i);\n        }\n\n        guesses *= shifted_variations;\n      }\n    }\n\n    return guesses;\n  },\n  dictionary_guesses: function (match) {\n    var reversed_variations;\n    match.base_guesses = match.rank;\n    match.uppercase_variations = this.uppercase_variations(match);\n    match.l33t_variations = this.l33t_variations(match);\n    reversed_variations = match.reversed && 2 || 1;\n    return match.base_guesses * match.uppercase_variations * match.l33t_variations * reversed_variations;\n  },\n  START_UPPER: /^[A-Z][^A-Z]+$/,\n  END_UPPER: /^[^A-Z]+[A-Z]$/,\n  ALL_UPPER: /^[^a-z]+$/,\n  ALL_LOWER: /^[^A-Z]+$/,\n  uppercase_variations: function (match) {\n    var L, U, chr, i, len, o, q, ref, ref1, regex, variations, word;\n    word = match.token;\n\n    if (word.match(this.ALL_LOWER) || word.toLowerCase() === word) {\n      return 1;\n    }\n\n    ref = [this.START_UPPER, this.END_UPPER, this.ALL_UPPER];\n\n    for (o = 0, len = ref.length; o < len; o++) {\n      regex = ref[o];\n\n      if (word.match(regex)) {\n        return 2;\n      }\n    }\n\n    U = function () {\n      var len1, q, ref1, results;\n      ref1 = word.split('');\n      results = [];\n\n      for (q = 0, len1 = ref1.length; q < len1; q++) {\n        chr = ref1[q];\n\n        if (chr.match(/[A-Z]/)) {\n          results.push(chr);\n        }\n      }\n\n      return results;\n    }().length;\n\n    L = function () {\n      var len1, q, ref1, results;\n      ref1 = word.split('');\n      results = [];\n\n      for (q = 0, len1 = ref1.length; q < len1; q++) {\n        chr = ref1[q];\n\n        if (chr.match(/[a-z]/)) {\n          results.push(chr);\n        }\n      }\n\n      return results;\n    }().length;\n\n    variations = 0;\n\n    for (i = q = 1, ref1 = Math.min(U, L); 1 <= ref1 ? q <= ref1 : q >= ref1; i = 1 <= ref1 ? ++q : --q) {\n      variations += this.nCk(U + L, i);\n    }\n\n    return variations;\n  },\n  l33t_variations: function (match) {\n    var S, U, chr, chrs, i, o, p, possibilities, ref, ref1, subbed, unsubbed, variations;\n\n    if (!match.l33t) {\n      return 1;\n    }\n\n    variations = 1;\n    ref = match.sub;\n\n    for (subbed in ref) {\n      unsubbed = ref[subbed];\n      chrs = match.token.toLowerCase().split('');\n\n      S = function () {\n        var len, o, results;\n        results = [];\n\n        for (o = 0, len = chrs.length; o < len; o++) {\n          chr = chrs[o];\n\n          if (chr === subbed) {\n            results.push(chr);\n          }\n        }\n\n        return results;\n      }().length;\n\n      U = function () {\n        var len, o, results;\n        results = [];\n\n        for (o = 0, len = chrs.length; o < len; o++) {\n          chr = chrs[o];\n\n          if (chr === unsubbed) {\n            results.push(chr);\n          }\n        }\n\n        return results;\n      }().length;\n\n      if (S === 0 || U === 0) {\n        variations *= 2;\n      } else {\n        p = Math.min(U, S);\n        possibilities = 0;\n\n        for (i = o = 1, ref1 = p; 1 <= ref1 ? o <= ref1 : o >= ref1; i = 1 <= ref1 ? ++o : --o) {\n          possibilities += this.nCk(U + S, i);\n        }\n\n        variations *= possibilities;\n      }\n    }\n\n    return variations;\n  }\n};\nmodule.exports = scoring;","map":{"version":3,"sources":["src/scoring.coffee"],"names":[],"mappings":"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","sourceRoot":"..","sourcesContent":["// Generated by CoffeeScript 1.10.0\nvar BRUTEFORCE_CARDINALITY, MIN_GUESSES_BEFORE_GROWING_SEQUENCE, MIN_SUBMATCH_GUESSES_MULTI_CHAR, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, adjacency_graphs, calc_average_degree, k, scoring, v;\n\nadjacency_graphs = require('./adjacency_graphs');\n\ncalc_average_degree = function(graph) {\n  var average, k, key, n, neighbors, v;\n  average = 0;\n  for (key in graph) {\n    neighbors = graph[key];\n    average += ((function() {\n      var len, o, results;\n      results = [];\n      for (o = 0, len = neighbors.length; o < len; o++) {\n        n = neighbors[o];\n        if (n) {\n          results.push(n);\n        }\n      }\n      return results;\n    })()).length;\n  }\n  average /= ((function() {\n    var results;\n    results = [];\n    for (k in graph) {\n      v = graph[k];\n      results.push(k);\n    }\n    return results;\n  })()).length;\n  return average;\n};\n\nBRUTEFORCE_CARDINALITY = 10;\n\nMIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\n\nMIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\n\nMIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\n\nscoring = {\n  nCk: function(n, k) {\n    var d, o, r, ref;\n    if (k > n) {\n      return 0;\n    }\n    if (k === 0) {\n      return 1;\n    }\n    r = 1;\n    for (d = o = 1, ref = k; 1 <= ref ? o <= ref : o >= ref; d = 1 <= ref ? ++o : --o) {\n      r *= n;\n      r /= d;\n      n -= 1;\n    }\n    return r;\n  },\n  log10: function(n) {\n    return Math.log(n) / Math.log(10);\n  },\n  log2: function(n) {\n    return Math.log(n) / Math.log(2);\n  },\n  factorial: function(n) {\n    var f, i, o, ref;\n    if (n < 2) {\n      return 1;\n    }\n    f = 1;\n    for (i = o = 2, ref = n; 2 <= ref ? o <= ref : o >= ref; i = 2 <= ref ? ++o : --o) {\n      f *= i;\n    }\n    return f;\n  },\n  most_guessable_match_sequence: function(password, matches, _exclude_additive) {\n    var _, bruteforce_update, guesses, k, l, len, len1, len2, lst, m, make_bruteforce_match, matches_by_j, n, o, optimal, optimal_l, optimal_match_sequence, q, ref, ref1, u, unwind, update, w;\n    if (_exclude_additive == null) {\n      _exclude_additive = false;\n    }\n    n = password.length;\n    matches_by_j = (function() {\n      var o, ref, results;\n      results = [];\n      for (_ = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; _ = 0 <= ref ? ++o : --o) {\n        results.push([]);\n      }\n      return results;\n    })();\n    for (o = 0, len = matches.length; o < len; o++) {\n      m = matches[o];\n      matches_by_j[m.j].push(m);\n    }\n    for (q = 0, len1 = matches_by_j.length; q < len1; q++) {\n      lst = matches_by_j[q];\n      lst.sort(function(m1, m2) {\n        return m1.i - m2.i;\n      });\n    }\n    optimal = {\n      m: (function() {\n        var ref, results, u;\n        results = [];\n        for (_ = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; _ = 0 <= ref ? ++u : --u) {\n          results.push({});\n        }\n        return results;\n      })(),\n      pi: (function() {\n        var ref, results, u;\n        results = [];\n        for (_ = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; _ = 0 <= ref ? ++u : --u) {\n          results.push({});\n        }\n        return results;\n      })(),\n      g: (function() {\n        var ref, results, u;\n        results = [];\n        for (_ = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; _ = 0 <= ref ? ++u : --u) {\n          results.push({});\n        }\n        return results;\n      })()\n    };\n    update = (function(_this) {\n      return function(m, l) {\n        var competing_g, competing_l, g, k, pi, ref;\n        k = m.j;\n        pi = _this.estimate_guesses(m, password);\n        if (l > 1) {\n          pi *= optimal.pi[m.i - 1][l - 1];\n        }\n        g = _this.factorial(l) * pi;\n        if (!_exclude_additive) {\n          g += Math.pow(MIN_GUESSES_BEFORE_GROWING_SEQUENCE, l - 1);\n        }\n        ref = optimal.g[k];\n        for (competing_l in ref) {\n          competing_g = ref[competing_l];\n          if (competing_l > l) {\n            continue;\n          }\n          if (competing_g <= g) {\n            return;\n          }\n        }\n        optimal.g[k][l] = g;\n        optimal.m[k][l] = m;\n        return optimal.pi[k][l] = pi;\n      };\n    })(this);\n    bruteforce_update = (function(_this) {\n      return function(k) {\n        var i, l, last_m, ref, results, u;\n        m = make_bruteforce_match(0, k);\n        update(m, 1);\n        results = [];\n        for (i = u = 1, ref = k; 1 <= ref ? u <= ref : u >= ref; i = 1 <= ref ? ++u : --u) {\n          m = make_bruteforce_match(i, k);\n          results.push((function() {\n            var ref1, results1;\n            ref1 = optimal.m[i - 1];\n            results1 = [];\n            for (l in ref1) {\n              last_m = ref1[l];\n              l = parseInt(l);\n              if (last_m.pattern === 'bruteforce') {\n                continue;\n              }\n              results1.push(update(m, l + 1));\n            }\n            return results1;\n          })());\n        }\n        return results;\n      };\n    })(this);\n    make_bruteforce_match = (function(_this) {\n      return function(i, j) {\n        return {\n          pattern: 'bruteforce',\n          token: password.slice(i, +j + 1 || 9e9),\n          i: i,\n          j: j\n        };\n      };\n    })(this);\n    unwind = (function(_this) {\n      return function(n) {\n        var candidate_g, candidate_l, g, k, l, optimal_match_sequence, ref;\n        optimal_match_sequence = [];\n        k = n - 1;\n        l = void 0;\n        g = Infinity;\n        ref = optimal.g[k];\n        for (candidate_l in ref) {\n          candidate_g = ref[candidate_l];\n          if (candidate_g < g) {\n            l = candidate_l;\n            g = candidate_g;\n          }\n        }\n        while (k >= 0) {\n          m = optimal.m[k][l];\n          optimal_match_sequence.unshift(m);\n          k = m.i - 1;\n          l--;\n        }\n        return optimal_match_sequence;\n      };\n    })(this);\n    for (k = u = 0, ref = n; 0 <= ref ? u < ref : u > ref; k = 0 <= ref ? ++u : --u) {\n      ref1 = matches_by_j[k];\n      for (w = 0, len2 = ref1.length; w < len2; w++) {\n        m = ref1[w];\n        if (m.i > 0) {\n          for (l in optimal.m[m.i - 1]) {\n            l = parseInt(l);\n            update(m, l + 1);\n          }\n        } else {\n          update(m, 1);\n        }\n      }\n      bruteforce_update(k);\n    }\n    optimal_match_sequence = unwind(n);\n    optimal_l = optimal_match_sequence.length;\n    if (password.length === 0) {\n      guesses = 1;\n    } else {\n      guesses = optimal.g[n - 1][optimal_l];\n    }\n    return {\n      password: password,\n      guesses: guesses,\n      guesses_log10: this.log10(guesses),\n      sequence: optimal_match_sequence\n    };\n  },\n  estimate_guesses: function(match, password) {\n    var estimation_functions, guesses, min_guesses;\n    if (match.guesses != null) {\n      return match.guesses;\n    }\n    min_guesses = 1;\n    if (match.token.length < password.length) {\n      min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR : MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n    }\n    estimation_functions = {\n      bruteforce: this.bruteforce_guesses,\n      dictionary: this.dictionary_guesses,\n      spatial: this.spatial_guesses,\n      repeat: this.repeat_guesses,\n      sequence: this.sequence_guesses,\n      regex: this.regex_guesses,\n      date: this.date_guesses\n    };\n    guesses = estimation_functions[match.pattern].call(this, match);\n    match.guesses = Math.max(guesses, min_guesses);\n    match.guesses_log10 = this.log10(match.guesses);\n    return match.guesses;\n  },\n  bruteforce_guesses: function(match) {\n    var guesses, min_guesses;\n    guesses = Math.pow(BRUTEFORCE_CARDINALITY, match.token.length);\n    if (guesses === Number.POSITIVE_INFINITY) {\n      guesses = Number.MAX_VALUE;\n    }\n    min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1 : MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n    return Math.max(guesses, min_guesses);\n  },\n  repeat_guesses: function(match) {\n    return match.base_guesses * match.repeat_count;\n  },\n  sequence_guesses: function(match) {\n    var base_guesses, first_chr;\n    first_chr = match.token.charAt(0);\n    if (first_chr === 'a' || first_chr === 'A' || first_chr === 'z' || first_chr === 'Z' || first_chr === '0' || first_chr === '1' || first_chr === '9') {\n      base_guesses = 4;\n    } else {\n      if (first_chr.match(/\\d/)) {\n        base_guesses = 10;\n      } else {\n        base_guesses = 26;\n      }\n    }\n    if (!match.ascending) {\n      base_guesses *= 2;\n    }\n    return base_guesses * match.token.length;\n  },\n  MIN_YEAR_SPACE: 20,\n  REFERENCE_YEAR: new Date().getFullYear(),\n  regex_guesses: function(match) {\n    var char_class_bases, year_space;\n    char_class_bases = {\n      alpha_lower: 26,\n      alpha_upper: 26,\n      alpha: 52,\n      alphanumeric: 62,\n      digits: 10,\n      symbols: 33\n    };\n    if (match.regex_name in char_class_bases) {\n      return Math.pow(char_class_bases[match.regex_name], match.token.length);\n    } else {\n      switch (match.regex_name) {\n        case 'recent_year':\n          year_space = Math.abs(parseInt(match.regex_match[0]) - this.REFERENCE_YEAR);\n          year_space = Math.max(year_space, this.MIN_YEAR_SPACE);\n          return year_space;\n      }\n    }\n  },\n  date_guesses: function(match) {\n    var guesses, year_space;\n    year_space = Math.max(Math.abs(match.year - this.REFERENCE_YEAR), this.MIN_YEAR_SPACE);\n    guesses = year_space * 365;\n    if (match.separator) {\n      guesses *= 4;\n    }\n    return guesses;\n  },\n  KEYBOARD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.qwerty),\n  KEYPAD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.keypad),\n  KEYBOARD_STARTING_POSITIONS: ((function() {\n    var ref, results;\n    ref = adjacency_graphs.qwerty;\n    results = [];\n    for (k in ref) {\n      v = ref[k];\n      results.push(k);\n    }\n    return results;\n  })()).length,\n  KEYPAD_STARTING_POSITIONS: ((function() {\n    var ref, results;\n    ref = adjacency_graphs.keypad;\n    results = [];\n    for (k in ref) {\n      v = ref[k];\n      results.push(k);\n    }\n    return results;\n  })()).length,\n  spatial_guesses: function(match) {\n    var L, S, U, d, guesses, i, j, o, possible_turns, q, ref, ref1, ref2, ref3, s, shifted_variations, t, u;\n    if ((ref = match.graph) === 'qwerty' || ref === 'dvorak') {\n      s = this.KEYBOARD_STARTING_POSITIONS;\n      d = this.KEYBOARD_AVERAGE_DEGREE;\n    } else {\n      s = this.KEYPAD_STARTING_POSITIONS;\n      d = this.KEYPAD_AVERAGE_DEGREE;\n    }\n    guesses = 0;\n    L = match.token.length;\n    t = match.turns;\n    for (i = o = 2, ref1 = L; 2 <= ref1 ? o <= ref1 : o >= ref1; i = 2 <= ref1 ? ++o : --o) {\n      possible_turns = Math.min(t, i - 1);\n      for (j = q = 1, ref2 = possible_turns; 1 <= ref2 ? q <= ref2 : q >= ref2; j = 1 <= ref2 ? ++q : --q) {\n        guesses += this.nCk(i - 1, j - 1) * s * Math.pow(d, j);\n      }\n    }\n    if (match.shifted_count) {\n      S = match.shifted_count;\n      U = match.token.length - match.shifted_count;\n      if (S === 0 || U === 0) {\n        guesses *= 2;\n      } else {\n        shifted_variations = 0;\n        for (i = u = 1, ref3 = Math.min(S, U); 1 <= ref3 ? u <= ref3 : u >= ref3; i = 1 <= ref3 ? ++u : --u) {\n          shifted_variations += this.nCk(S + U, i);\n        }\n        guesses *= shifted_variations;\n      }\n    }\n    return guesses;\n  },\n  dictionary_guesses: function(match) {\n    var reversed_variations;\n    match.base_guesses = match.rank;\n    match.uppercase_variations = this.uppercase_variations(match);\n    match.l33t_variations = this.l33t_variations(match);\n    reversed_variations = match.reversed && 2 || 1;\n    return match.base_guesses * match.uppercase_variations * match.l33t_variations * reversed_variations;\n  },\n  START_UPPER: /^[A-Z][^A-Z]+$/,\n  END_UPPER: /^[^A-Z]+[A-Z]$/,\n  ALL_UPPER: /^[^a-z]+$/,\n  ALL_LOWER: /^[^A-Z]+$/,\n  uppercase_variations: function(match) {\n    var L, U, chr, i, len, o, q, ref, ref1, regex, variations, word;\n    word = match.token;\n    if (word.match(this.ALL_LOWER) || word.toLowerCase() === word) {\n      return 1;\n    }\n    ref = [this.START_UPPER, this.END_UPPER, this.ALL_UPPER];\n    for (o = 0, len = ref.length; o < len; o++) {\n      regex = ref[o];\n      if (word.match(regex)) {\n        return 2;\n      }\n    }\n    U = ((function() {\n      var len1, q, ref1, results;\n      ref1 = word.split('');\n      results = [];\n      for (q = 0, len1 = ref1.length; q < len1; q++) {\n        chr = ref1[q];\n        if (chr.match(/[A-Z]/)) {\n          results.push(chr);\n        }\n      }\n      return results;\n    })()).length;\n    L = ((function() {\n      var len1, q, ref1, results;\n      ref1 = word.split('');\n      results = [];\n      for (q = 0, len1 = ref1.length; q < len1; q++) {\n        chr = ref1[q];\n        if (chr.match(/[a-z]/)) {\n          results.push(chr);\n        }\n      }\n      return results;\n    })()).length;\n    variations = 0;\n    for (i = q = 1, ref1 = Math.min(U, L); 1 <= ref1 ? q <= ref1 : q >= ref1; i = 1 <= ref1 ? ++q : --q) {\n      variations += this.nCk(U + L, i);\n    }\n    return variations;\n  },\n  l33t_variations: function(match) {\n    var S, U, chr, chrs, i, o, p, possibilities, ref, ref1, subbed, unsubbed, variations;\n    if (!match.l33t) {\n      return 1;\n    }\n    variations = 1;\n    ref = match.sub;\n    for (subbed in ref) {\n      unsubbed = ref[subbed];\n      chrs = match.token.toLowerCase().split('');\n      S = ((function() {\n        var len, o, results;\n        results = [];\n        for (o = 0, len = chrs.length; o < len; o++) {\n          chr = chrs[o];\n          if (chr === subbed) {\n            results.push(chr);\n          }\n        }\n        return results;\n      })()).length;\n      U = ((function() {\n        var len, o, results;\n        results = [];\n        for (o = 0, len = chrs.length; o < len; o++) {\n          chr = chrs[o];\n          if (chr === unsubbed) {\n            results.push(chr);\n          }\n        }\n        return results;\n      })()).length;\n      if (S === 0 || U === 0) {\n        variations *= 2;\n      } else {\n        p = Math.min(U, S);\n        possibilities = 0;\n        for (i = o = 1, ref1 = p; 1 <= ref1 ? o <= ref1 : o >= ref1; i = 1 <= ref1 ? ++o : --o) {\n          possibilities += this.nCk(U + S, i);\n        }\n        variations *= possibilities;\n      }\n    }\n    return variations;\n  }\n};\n\nmodule.exports = scoring;\n\n//# sourceMappingURL=scoring.js.map\n"]},"metadata":{},"sourceType":"script"}