{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { getDefaultLocale, setDefaultLocale, getLocaleData, addLocaleData } from './LocaleDataStore';\nimport resolveLocale from './resolveLocale'; // Valid time units.\n\nexport var UNITS = [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"]; // Valid values for the `numeric` option.\n\nvar NUMERIC_VALUES = [\"auto\", \"always\"]; // Valid values for the `style` option.\n\nvar STYLE_VALUES = [\"long\", \"short\", \"narrow\"];\n/**\r\n * Polyfill for `Intl.RelativeTimeFormat` proposal.\r\n * https://github.com/tc39/proposal-intl-relative-time\r\n * https://github.com/tc39/proposal-intl-relative-time/issues/55\r\n */\n\nvar RelativeTimeFormat = /*#__PURE__*/function () {\n  /**\r\n   * @param {(string|string[])} [locales] - Preferred locales (or locale).\r\n   * @param {Object} [options] - Formatting options.\r\n   * @param {string} [options.style=\"long\"] - One of: \"long\", \"short\", \"narrow\".\r\n   * @param {string} [options.numeric=\"always\"] - (Version >= 2) One of: \"always\", \"auto\".\r\n   * @param {string} [options.localeMatcher=\"lookup\"] - One of: \"lookup\", \"best fit\". Currently only \"lookup\" is supported.\r\n   */\n  function RelativeTimeFormat() {\n    var locales = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, RelativeTimeFormat);\n\n    _defineProperty(this, \"numeric\", \"always\");\n\n    _defineProperty(this, \"style\", \"long\");\n\n    _defineProperty(this, \"localeMatcher\", \"lookup\");\n\n    var numeric = options.numeric,\n        style = options.style,\n        localeMatcher = options.localeMatcher; // Set `numeric` option.\n\n    if (numeric) {\n      if (NUMERIC_VALUES.indexOf(numeric) < 0) {\n        throw new RangeError(\"Invalid \\\"numeric\\\" option: \".concat(numeric));\n      }\n\n      this.numeric = numeric;\n    } // Set `style` option.\n\n\n    if (style) {\n      if (STYLE_VALUES.indexOf(style) < 0) {\n        throw new RangeError(\"Invalid \\\"style\\\" option: \".concat(style));\n      }\n\n      this.style = style;\n    } // Set `localeMatcher` option.\n\n\n    if (localeMatcher) {\n      this.localeMatcher = localeMatcher;\n    } // Set `locale`.\n    // Convert `locales` to an array.\n\n\n    if (typeof locales === 'string') {\n      locales = [locales];\n    } // Add default locale.\n\n\n    locales.push(getDefaultLocale()); // Choose the most appropriate locale.\n\n    this.locale = RelativeTimeFormat.supportedLocalesOf(locales, {\n      localeMatcher: this.localeMatcher\n    })[0];\n\n    if (!this.locale) {\n      throw new TypeError(\"No supported locale was found\");\n    }\n\n    this.locale = resolveLocale(this.locale, {\n      localeMatcher: this.localeMatcher\n    }); // Use `Intl.NumberFormat` for formatting numbers (when available).\n\n    if (typeof Intl !== 'undefined' && Intl.NumberFormat) {\n      this.numberFormat = new Intl.NumberFormat(this.locale);\n    }\n  }\n  /**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"2 days ago\"\r\n   * rtf.format(-2, \"day\")\r\n   * // Returns \"in 5 minutes\"\r\n   * rtf.format(5, \"minute\")\r\n   */\n\n\n  _createClass(RelativeTimeFormat, [{\n    key: \"format\",\n    value: function format(value, unit) {\n      return this.getRule(value, unit).replace('{0}', this.formatNumber(Math.abs(value)));\n    }\n    /**\r\n     * Formats time `value` in `units` (either in past or in future).\r\n     * @param {number} value - Time interval value.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @return {Object[]} The parts (`{ type, value }`).\r\n     * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n     * @example\r\n     * // Version 1.\r\n     * // Returns [\r\n     * //   { type: \"literal\", value: \"in \" },\r\n     * //   { type: \"day\", value: \"100\" },\r\n     * //   { type: \"literal\", value: \" days\" }\r\n     * // ]\r\n     * rtf.formatToParts(100, \"day\")\r\n     * //\r\n     * // Version 2.\r\n     * // Returns [\r\n     * //   { type: \"literal\", value: \"in \" },\r\n     * //   { type: \"integer\", value: \"100\", unit: \"day\" },\r\n     * //   { type: \"literal\", value: \" days\" }\r\n     * // ]\r\n     * rtf.formatToParts(100, \"day\")\r\n     */\n\n  }, {\n    key: \"formatToParts\",\n    value: function formatToParts(value, unit) {\n      var rule = this.getRule(value, unit);\n      var valueIndex = rule.indexOf(\"{0}\"); // \"yesterday\"/\"today\"/\"tomorrow\".\n\n      if (valueIndex < 0) {\n        return [{\n          type: \"literal\",\n          value: rule\n        }];\n      }\n\n      var parts = [];\n\n      if (valueIndex > 0) {\n        parts.push({\n          type: \"literal\",\n          value: rule.slice(0, valueIndex)\n        });\n      }\n\n      parts.push({\n        unit: unit,\n        type: \"integer\",\n        value: this.formatNumber(Math.abs(value))\n      });\n\n      if (valueIndex + \"{0}\".length < rule.length - 1) {\n        parts.push({\n          type: \"literal\",\n          value: rule.slice(valueIndex + \"{0}\".length)\n        });\n      }\n\n      return parts;\n    }\n    /**\r\n     * Returns formatting rule for `value` in `units` (either in past or in future).\r\n     * @param {number} value - Time interval value.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @return {string}\r\n     * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n     * @example\r\n     * // Returns \"{0} days ago\"\r\n     * getRule(-2, \"day\")\r\n     */\n\n  }, {\n    key: \"getRule\",\n    value: function getRule(value, unit) {\n      if (UNITS.indexOf(unit) < 0) {\n        throw new RangeError(\"Unknown time unit: \".concat(unit, \".\"));\n      } // Get locale-specific time interval formatting rules\n      // of a given `style` for the given value of measurement `unit`.\n      //\n      // E.g.:\n      //\n      // ```json\n      // {\n      //  \"past\": {\n      //    \"one\": \"a second ago\",\n      //    \"other\": \"{0} seconds ago\"\n      //  },\n      //  \"future\": {\n      //    \"one\": \"in a second\",\n      //    \"other\": \"in {0} seconds\"\n      //  }\n      // }\n      // ```\n      //\n\n\n      var unitRules = getLocaleData(this.locale)[this.style][unit]; // Special case for \"yesterday\"/\"today\"/\"tomorrow\".\n\n      if (this.numeric === \"auto\") {\n        // \"yesterday\", \"the day before yesterday\", etc.\n        if (value === -2 || value === -1) {\n          var message = unitRules[\"previous\".concat(value === -1 ? '' : '-' + Math.abs(value))];\n\n          if (message) {\n            return message;\n          }\n        } // \"tomorrow\", \"the day after tomorrow\", etc.\n        else if (value === 1 || value === 2) {\n            var _message = unitRules[\"next\".concat(value === 1 ? '' : '-' + Math.abs(value))];\n\n            if (_message) {\n              return _message;\n            }\n          } // \"today\"\n          else if (value === 0) {\n              if (unitRules.current) {\n                return unitRules.current;\n              }\n            }\n      } // Choose either \"past\" or \"future\" based on time `value` sign.\n      // If there's only \"other\" then it's being collapsed.\n      // (the resulting bundle size optimization technique)\n\n\n      var quantifierRules = unitRules[value <= 0 ? \"past\" : \"future\"]; // Bundle size optimization technique.\n\n      if (typeof quantifierRules === \"string\") {\n        return quantifierRules;\n      } // Quantify `value`.\n\n\n      var quantify = getLocaleData(this.locale).quantify;\n      var quantifier = quantify && quantify(Math.abs(value)); // There seems to be no such locale in CLDR\n      // for which `quantify` is missing\n      // and still `past` and `future` messages\n      // contain something other than \"other\".\n\n      /* istanbul ignore next */\n\n      quantifier = quantifier || 'other'; // \"other\" rule is supposed to be always present.\n      // If only \"other\" rule is present then \"rules\" is not an object and is a string.\n\n      return quantifierRules[quantifier] || quantifierRules.other;\n    }\n    /**\r\n     * Formats a number into a string.\r\n     * Uses `Intl.NumberFormat` when available.\r\n     * @param  {number} number\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"formatNumber\",\n    value: function formatNumber(number) {\n      return this.numberFormat ? this.numberFormat.format(number) : String(number);\n    }\n    /**\r\n     * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.\r\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"resolvedOptions\",\n    value: function resolvedOptions() {\n      return {\n        locale: this.locale,\n        style: this.style,\n        numeric: this.numeric\n      };\n    }\n  }]);\n\n  return RelativeTimeFormat;\n}();\n/**\r\n * Returns an array containing those of the provided locales\r\n * that are supported in collation without having to fall back\r\n * to the runtime's default locale.\r\n * @param {(string|string[])} locale - A string with a BCP 47 language tag, or an array of such strings. For the general form of the locales argument, see the Intl page.\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string[]} An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.\r\n * @example\r\n * var locales = ['ban', 'id-u-co-pinyin', 'es-PY']\r\n * var options = { localeMatcher: 'lookup' }\r\n * // Returns [\"id\", \"es-PY\"]\r\n * Intl.RelativeTimeFormat.supportedLocalesOf(locales, options)\r\n */\n\n\nexport { RelativeTimeFormat as default };\n\nRelativeTimeFormat.supportedLocalesOf = function (locales) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Convert `locales` to an array.\n\n  if (typeof locales === 'string') {\n    locales = [locales];\n  }\n\n  return locales.filter(function (locale) {\n    return resolveLocale(locale, options);\n  });\n};\n/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */\n\n\nRelativeTimeFormat.addLocale = addLocaleData;\n/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */\n\nRelativeTimeFormat.setDefaultLocale = setDefaultLocale;\n/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */\n\nRelativeTimeFormat.getDefaultLocale = getDefaultLocale;\n/**\r\n * Extracts language from an IETF BCP 47 language tag.\r\n * @param {string} languageTag - IETF BCP 47 language tag.\r\n * @return {string}\r\n * @example\r\n * // Returns \"he\"\r\n * getLanguageFromLanguageTag(\"he-IL-u-ca-hebrew-tz-jeruslm\")\r\n * // Returns \"ar\"\r\n * getLanguageFromLanguageTag(\"ar-u-nu-latn\")\r\n */\n// export function getLanguageFromLanguageTag(languageTag) {\n//   const hyphenIndex = languageTag.indexOf('-')\n//   if (hyphenIndex > 0) {\n//     return languageTag.slice(0, hyphenIndex)\n//   }\n//   return languageTag\n// }","map":{"version":3,"sources":["../source/RelativeTimeFormat.js"],"names":["UNITS","NUMERIC_VALUES","STYLE_VALUES","RelativeTimeFormat","locales","options","numeric","style","localeMatcher","getDefaultLocale","resolveLocale","Intl","value","unit","Math","rule","valueIndex","type","parts","unitRules","getLocaleData","message","quantifierRules","quantify","quantifier","number","String","locale"],"mappings":"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","sourcesContent":["import {\r\n  getDefaultLocale,\r\n  setDefaultLocale,\r\n  getLocaleData,\r\n  addLocaleData\r\n} from './LocaleDataStore'\r\n\r\nimport resolveLocale from './resolveLocale'\r\n\r\n// Valid time units.\r\nexport const UNITS = [\r\n  \"second\",\r\n  \"minute\",\r\n  \"hour\",\r\n  \"day\",\r\n  \"week\",\r\n  \"month\",\r\n  \"quarter\",\r\n  \"year\"\r\n]\r\n\r\n// Valid values for the `numeric` option.\r\nconst NUMERIC_VALUES = [\r\n  \"auto\",\r\n  \"always\"\r\n]\r\n\r\n// Valid values for the `style` option.\r\nconst STYLE_VALUES = [\r\n  \"long\",\r\n  \"short\",\r\n  \"narrow\"\r\n]\r\n\r\n/**\r\n * Polyfill for `Intl.RelativeTimeFormat` proposal.\r\n * https://github.com/tc39/proposal-intl-relative-time\r\n * https://github.com/tc39/proposal-intl-relative-time/issues/55\r\n */\r\nexport default class RelativeTimeFormat {\r\n  numeric = \"always\"\r\n  style = \"long\"\r\n  localeMatcher = \"lookup\"\r\n\r\n  /**\r\n   * @param {(string|string[])} [locales] - Preferred locales (or locale).\r\n   * @param {Object} [options] - Formatting options.\r\n   * @param {string} [options.style=\"long\"] - One of: \"long\", \"short\", \"narrow\".\r\n   * @param {string} [options.numeric=\"always\"] - (Version >= 2) One of: \"always\", \"auto\".\r\n   * @param {string} [options.localeMatcher=\"lookup\"] - One of: \"lookup\", \"best fit\". Currently only \"lookup\" is supported.\r\n   */\r\n  constructor(locales = [], options = {}) {\r\n    const {\r\n      numeric,\r\n      style,\r\n      localeMatcher\r\n    } = options\r\n\r\n    // Set `numeric` option.\r\n    if (numeric) {\r\n      if (NUMERIC_VALUES.indexOf(numeric) < 0) {\r\n        throw new RangeError(`Invalid \"numeric\" option: ${numeric}`)\r\n      }\r\n      this.numeric = numeric\r\n    }\r\n\r\n    // Set `style` option.\r\n    if (style) {\r\n      if (STYLE_VALUES.indexOf(style) < 0) {\r\n        throw new RangeError(`Invalid \"style\" option: ${style}`)\r\n      }\r\n      this.style = style\r\n    }\r\n\r\n    // Set `localeMatcher` option.\r\n    if (localeMatcher) {\r\n      this.localeMatcher = localeMatcher\r\n    }\r\n\r\n    // Set `locale`.\r\n    // Convert `locales` to an array.\r\n    if (typeof locales === 'string') {\r\n      locales = [locales]\r\n    }\r\n    // Add default locale.\r\n    locales.push(getDefaultLocale())\r\n    // Choose the most appropriate locale.\r\n    this.locale = RelativeTimeFormat.supportedLocalesOf(locales, {\r\n      localeMatcher: this.localeMatcher\r\n    })[0]\r\n    if (!this.locale) {\r\n      throw new TypeError(\"No supported locale was found\")\r\n    }\r\n    this.locale = resolveLocale(this.locale, {\r\n      localeMatcher: this.localeMatcher\r\n    })\r\n\r\n    // Use `Intl.NumberFormat` for formatting numbers (when available).\r\n    if (typeof Intl !== 'undefined' && Intl.NumberFormat) {\r\n      this.numberFormat = new Intl.NumberFormat(this.locale)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"2 days ago\"\r\n   * rtf.format(-2, \"day\")\r\n   * // Returns \"in 5 minutes\"\r\n   * rtf.format(5, \"minute\")\r\n   */\r\n  format(value, unit) {\r\n    return this.getRule(value, unit).replace('{0}', this.formatNumber(Math.abs(value)))\r\n  }\r\n\r\n  /**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {Object[]} The parts (`{ type, value }`).\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Version 1.\r\n   * // Returns [\r\n   * //   { type: \"literal\", value: \"in \" },\r\n   * //   { type: \"day\", value: \"100\" },\r\n   * //   { type: \"literal\", value: \" days\" }\r\n   * // ]\r\n   * rtf.formatToParts(100, \"day\")\r\n   * //\r\n   * // Version 2.\r\n   * // Returns [\r\n   * //   { type: \"literal\", value: \"in \" },\r\n   * //   { type: \"integer\", value: \"100\", unit: \"day\" },\r\n   * //   { type: \"literal\", value: \" days\" }\r\n   * // ]\r\n   * rtf.formatToParts(100, \"day\")\r\n   */\r\n  formatToParts(value, unit) {\r\n    const rule = this.getRule(value, unit)\r\n    const valueIndex = rule.indexOf(\"{0}\")\r\n    // \"yesterday\"/\"today\"/\"tomorrow\".\r\n    if (valueIndex < 0) {\r\n      return [{\r\n        type: \"literal\",\r\n        value: rule\r\n      }]\r\n    }\r\n    const parts = []\r\n    if (valueIndex > 0) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(0, valueIndex)\r\n      })\r\n    }\r\n    parts.push({\r\n      unit,\r\n      type: \"integer\",\r\n      value: this.formatNumber(Math.abs(value))\r\n    })\r\n    if (valueIndex + \"{0}\".length < rule.length - 1) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(valueIndex + \"{0}\".length)\r\n      })\r\n    }\r\n    return parts\r\n  }\r\n\r\n  /**\r\n   * Returns formatting rule for `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"{0} days ago\"\r\n   * getRule(-2, \"day\")\r\n   */\r\n  getRule(value, unit) {\r\n    if (UNITS.indexOf(unit) < 0) {\r\n      throw new RangeError(`Unknown time unit: ${unit}.`)\r\n    }\r\n    // Get locale-specific time interval formatting rules\r\n    // of a given `style` for the given value of measurement `unit`.\r\n    //\r\n    // E.g.:\r\n    //\r\n    // ```json\r\n    // {\r\n    //  \"past\": {\r\n    //    \"one\": \"a second ago\",\r\n    //    \"other\": \"{0} seconds ago\"\r\n    //  },\r\n    //  \"future\": {\r\n    //    \"one\": \"in a second\",\r\n    //    \"other\": \"in {0} seconds\"\r\n    //  }\r\n    // }\r\n    // ```\r\n    //\r\n    const unitRules = getLocaleData(this.locale)[this.style][unit]\r\n    // Special case for \"yesterday\"/\"today\"/\"tomorrow\".\r\n    if (this.numeric === \"auto\") {\r\n      // \"yesterday\", \"the day before yesterday\", etc.\r\n      if (value === -2 || value === -1) {\r\n        const message = unitRules[`previous${value === -1 ? '' : '-' + Math.abs(value)}`]\r\n        if (message) {\r\n          return message\r\n        }\r\n      }\r\n      // \"tomorrow\", \"the day after tomorrow\", etc.\r\n      else if (value === 1 || value === 2) {\r\n        const message = unitRules[`next${value === 1 ? '' : '-' + Math.abs(value)}`]\r\n        if (message) {\r\n          return message\r\n        }\r\n      }\r\n      // \"today\"\r\n      else if (value === 0) {\r\n        if (unitRules.current) {\r\n          return unitRules.current\r\n        }\r\n      }\r\n    }\r\n    // Choose either \"past\" or \"future\" based on time `value` sign.\r\n    // If there's only \"other\" then it's being collapsed.\r\n    // (the resulting bundle size optimization technique)\r\n    const quantifierRules = unitRules[value <= 0 ? \"past\" : \"future\"]\r\n    // Bundle size optimization technique.\r\n    if (typeof quantifierRules === \"string\") {\r\n      return quantifierRules\r\n    }\r\n    // Quantify `value`.\r\n    const quantify = getLocaleData(this.locale).quantify\r\n    let quantifier = quantify && quantify(Math.abs(value))\r\n    // There seems to be no such locale in CLDR\r\n    // for which `quantify` is missing\r\n    // and still `past` and `future` messages\r\n    // contain something other than \"other\".\r\n    /* istanbul ignore next */\r\n    quantifier = quantifier || 'other'\r\n    // \"other\" rule is supposed to be always present.\r\n    // If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n    return quantifierRules[quantifier] || quantifierRules.other\r\n  }\r\n\r\n  /**\r\n   * Formats a number into a string.\r\n   * Uses `Intl.NumberFormat` when available.\r\n   * @param  {number} number\r\n   * @return {string}\r\n   */\r\n  formatNumber(number) {\r\n    return this.numberFormat ? this.numberFormat.format(number) : String(number)\r\n  }\r\n\r\n  /**\r\n   * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.\r\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions\r\n   * @return {Object}\r\n   */\r\n  resolvedOptions() {\r\n    return {\r\n      locale: this.locale,\r\n      style: this.style,\r\n      numeric: this.numeric\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an array containing those of the provided locales\r\n * that are supported in collation without having to fall back\r\n * to the runtime's default locale.\r\n * @param {(string|string[])} locale - A string with a BCP 47 language tag, or an array of such strings. For the general form of the locales argument, see the Intl page.\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string[]} An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.\r\n * @example\r\n * var locales = ['ban', 'id-u-co-pinyin', 'es-PY']\r\n * var options = { localeMatcher: 'lookup' }\r\n * // Returns [\"id\", \"es-PY\"]\r\n * Intl.RelativeTimeFormat.supportedLocalesOf(locales, options)\r\n */\r\nRelativeTimeFormat.supportedLocalesOf = function(locales, options = {}) {\r\n  // Convert `locales` to an array.\r\n  if (typeof locales === 'string') {\r\n    locales = [locales]\r\n  }\r\n  return locales.filter(locale => resolveLocale(locale, options))\r\n}\r\n\r\n/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */\r\nRelativeTimeFormat.addLocale = addLocaleData\r\n\r\n/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */\r\nRelativeTimeFormat.setDefaultLocale = setDefaultLocale\r\n\r\n/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */\r\nRelativeTimeFormat.getDefaultLocale = getDefaultLocale\r\n\r\n/**\r\n * Extracts language from an IETF BCP 47 language tag.\r\n * @param {string} languageTag - IETF BCP 47 language tag.\r\n * @return {string}\r\n * @example\r\n * // Returns \"he\"\r\n * getLanguageFromLanguageTag(\"he-IL-u-ca-hebrew-tz-jeruslm\")\r\n * // Returns \"ar\"\r\n * getLanguageFromLanguageTag(\"ar-u-nu-latn\")\r\n */\r\n// export function getLanguageFromLanguageTag(languageTag) {\r\n//   const hyphenIndex = languageTag.indexOf('-')\r\n//   if (hyphenIndex > 0) {\r\n//     return languageTag.slice(0, hyphenIndex)\r\n//   }\r\n//   return languageTag\r\n// }"]},"metadata":{},"sourceType":"module"}