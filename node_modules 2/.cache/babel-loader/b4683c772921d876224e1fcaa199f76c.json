{"ast":null,"code":"import API from \"../../../api/API\";\nimport util from \"../../../util\";\nimport * as actionCreators from \"./actionCreators\";\nimport { clearError, setServerError, setModalKey } from \"../../status/actionCreators\";\nimport { setSortedCourses } from \"../../sorted-courses/actionCreators\";\nimport selectors from \"../../selectors\";\nimport { changeCourse } from \"../../current-course/actionCreators\";\nimport { modalTypes } from \"../../../components/modals/redux/modalTypes\";\nimport { getUserType } from \"../../../api/tokenService\";\n/**\n * @function fetchCourses\n * Fetch the information for all courses in the given array\n * @returns {function} Redux thunk action\n */\n\nexport const fetchCourses = () => async (dispatch, getState) => {\n  var _sorted$;\n\n  const courses = await API.getCourses();\n  dispatch(setSortedCourses(courses));\n  const activeCourses = courses.filter(item => item.archived !== true);\n\n  for (const course of activeCourses) {\n    dispatch(actionCreators.setCourse(course._id, course));\n  } // Set the selected course to the first one in sorted courses or from the url\n\n\n  const selectedCourse = selectors.getCourseID(getState());\n  const sorted = selectors.getSortedCourses(getState());\n  const path = window.location.pathname.substr(1).split(\"/\");\n  const redirectCourse = path[0] === \"courses\" ? path[1] : (_sorted$ = sorted[0]) === null || _sorted$ === void 0 ? void 0 : _sorted$._id;\n\n  if (!selectedCourse && sorted.length !== 0) {\n    await dispatch(changeCourse(redirectCourse));\n  }\n};\n/**\n * @function fetchFullCourse\n * Fetch the full information for the currently selected course\n * @returns {function} Redux thunk action\n */\n\nexport const fetchFullCourse = () => async (dispatch, getState) => {\n  const course = selectors.getCourse(getState());\n  const session = selectors.getSession(getState());\n  if (!course) return; // don't load if there is no active course\n\n  if (course.discussions && (session || !course.ActiveSession)) return; // used cached values if they exist\n\n  if (course === null || course === void 0 ? void 0 : course.activeSession) {\n    await dispatch(fetchSession());\n  }\n\n  await dispatch(fetchDiscussions());\n};\n/**\n * Used for polling. Refreshes questions array into redux\n * @returns Redux thunk action\n */\n\nexport const pollQuestions = () => async (dispatch, getState) => {\n  const session = selectors.getSession(getState());\n\n  if (session) {\n    await dispatch(fetchQuestions(session));\n  }\n};\n/**\n * Used for polling. Refreshes discussions array into redux\n * @returns Redux thunk action\n */\n\nexport const pollDiscussions = () => async (dispatch, getState) => {\n  const course = selectors.getCourse(getState());\n\n  if (course) {\n    await dispatch(fetchDiscussions());\n  }\n};\n/**\n * @function fetchSession\n * Fetch the active session for the given course if there is one\n * @returns {function} Redux thunk action\n */\n\nexport const fetchSession = () => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n\n  try {\n    const sessions = await API.getSession(courseID);\n    await dispatch(fetchQuestions(sessions[0]));\n    dispatch(actionCreators.setSession(courseID, sessions[0]));\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"loading the active session\"));\n    console.error(error);\n  }\n};\n/**\n * @function fetchQuestions\n * Fetch the questions for an active session\n * @param {Object} session\n * @returns {function} Redux thunk action\n */\n\nexport const fetchQuestions = session => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  const course = selectors.getCourse(getState());\n  const userID = selectors.getUserID(getState());\n\n  try {\n    const questions = await API.getQuestions(session._id);\n    const stats = await API.getStats(session._id);\n    dispatch(actionCreators.setStats(courseID, stats));\n\n    if (questions) {\n      dispatch(actionCreators.setQuestions(courseID, questions));\n      let activeQuestion;\n\n      if (userIsAssistantOrInstructor(course)) {\n        // Check if user is helping any student\n        activeQuestion = getMyHelpingQuestion(questions, userID);\n      } else {\n        var _activeQuestion$helps;\n\n        // User is a student in this course\n        // Get full attribute question from DB if it exists\n        activeQuestion = studentHasQuestion(questions, userID) && (await API.getMyQuestion(courseID)); //get the most recent active help\n\n        const activeHelp = (_activeQuestion$helps = activeQuestion.helps) === null || _activeQuestion$helps === void 0 ? void 0 : _activeQuestion$helps.filter(help => help.active).pop(); // show a modal if the student has an assistant on their question\n\n        if (activeHelp && !activeHelp.joinedAt) {\n          dispatch(setModalKey(modalTypes.HELP_READY));\n        }\n      }\n\n      dispatch(actionCreators.setActiveQuestion(courseID, activeQuestion));\n    }\n  } catch (error) {\n    console.error(error);\n  }\n};\n/**\n * Fetch the discussions for a given course as well as the user's active discussion\n * @param {*} courseID\n * @returns {function} Redux thunk action\n */\n\nexport const fetchDiscussions = () => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  const userID = selectors.getUserID(getState());\n\n  try {\n    const discussions = await API.getDiscussions(courseID);\n    const description = selectors.getDescription(getState()); // Sort by description of user's Woto or question\n\n    if ((description === null || description === void 0 ? void 0 : description.length) !== 0) {\n      util.sortDiscussionsByDescription(discussions, description);\n    }\n\n    dispatch(actionCreators.setDiscussions(courseID, discussions));\n    const activeDiscussion = getMyDiscussion(discussions, userID);\n    activeDiscussion && dispatch(actionCreators.setActiveDiscussion(courseID, activeDiscussion));\n  } catch (error) {\n    console.error(error);\n  }\n};\n/**\n * @function studentHasQuestion\n * Determine whether or not user has an active question\n * @param {Array} questions\n * @param {String} userID\n * @returns {Boolean} whether or not signed in user has a question\n */\n\nconst studentHasQuestion = (questions, userID) => {\n  for (const item of questions) {\n    var _item$question;\n\n    if ((item === null || item === void 0 ? void 0 : (_item$question = item.question) === null || _item$question === void 0 ? void 0 : _item$question.student) === userID) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @function getMyHelpingQuestion\n * Determine whether or not user is in any questions\n * @param {Array} questions\n * @param {String} userID\n * @returns {Object} the question user is helping\n */\n\n\nconst getMyHelpingQuestion = (questions, userID) => {\n  // filter out inactive questions\n  const filteredQuestions = questions.filter(item => item.active);\n\n  for (const question of filteredQuestions) {\n    for (const help of question.helps) {\n      if (help.assistant.id === userID) {\n        return question;\n      }\n    }\n  }\n};\n/**\n * @function getMyDiscussion\n * Determine whether or not user is in any active discussions\n * @param {Array} discussions\n * @param {String} userID\n * @returns {Object} the question user is helping\n */\n\n\nconst getMyDiscussion = (discussions, userID) => {\n  const activeDiscussions = discussions.filter(discussion => discussion.archived === false);\n\n  for (const discussion of activeDiscussions) {\n    for (const participant of discussion.participants) {\n      if (participant.participant === userID && participant.active === true) {\n        return discussion;\n      }\n    }\n  }\n};\n/**\n * @function userIsAssistantOrInstructor\n * @param {Object} course\n * @returns whether or not user is TA or instructor in the course\n */\n\n\nexport const userIsAssistantOrInstructor = course => {\n  return course.role === \"TA\" || getUserType() === \"instructor\";\n};","map":{"version":3,"sources":["/Users/jasmineharris/Desktop/Elite/woto/src/redux/courses/actions/fetches.js"],"names":["API","util","actionCreators","clearError","setServerError","setModalKey","setSortedCourses","selectors","changeCourse","modalTypes","getUserType","fetchCourses","dispatch","getState","courses","getCourses","activeCourses","filter","item","archived","course","setCourse","_id","selectedCourse","getCourseID","sorted","getSortedCourses","path","window","location","pathname","substr","split","redirectCourse","length","fetchFullCourse","getCourse","session","getSession","discussions","ActiveSession","activeSession","fetchSession","fetchDiscussions","pollQuestions","fetchQuestions","pollDiscussions","courseID","sessions","setSession","error","console","userID","getUserID","questions","getQuestions","stats","getStats","setStats","setQuestions","activeQuestion","userIsAssistantOrInstructor","getMyHelpingQuestion","studentHasQuestion","getMyQuestion","activeHelp","helps","help","active","pop","joinedAt","HELP_READY","setActiveQuestion","getDiscussions","description","getDescription","sortDiscussionsByDescription","setDiscussions","activeDiscussion","getMyDiscussion","setActiveDiscussion","question","student","filteredQuestions","assistant","id","activeDiscussions","discussion","participant","participants","role"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,kBAAhB;AACA,OAAOC,IAAP,MAAiB,eAAjB;AACA,OAAO,KAAKC,cAAZ,MAAgC,kBAAhC;AACA,SACEC,UADF,EAEEC,cAFF,EAGEC,WAHF,QAIO,6BAJP;AAKA,SAASC,gBAAT,QAAiC,qCAAjC;AAEA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,SAASC,YAAT,QAA6B,qCAA7B;AACA,SAASC,UAAT,QAA2B,6CAA3B;AACA,SAASC,WAAT,QAA4B,2BAA5B;AACA;;;;;;AAKA,OAAO,MAAMC,YAAY,GAAG,MAAM,OAAOC,QAAP,EAAiBC,QAAjB,KAA8B;AAAA;;AAC9D,QAAMC,OAAO,GAAG,MAAMd,GAAG,CAACe,UAAJ,EAAtB;AAEAH,EAAAA,QAAQ,CAACN,gBAAgB,CAACQ,OAAD,CAAjB,CAAR;AAEA,QAAME,aAAa,GAAGF,OAAO,CAACG,MAAR,CAAgBC,IAAD,IAAUA,IAAI,CAACC,QAAL,KAAkB,IAA3C,CAAtB;;AAEA,OAAK,MAAMC,MAAX,IAAqBJ,aAArB,EAAoC;AAClCJ,IAAAA,QAAQ,CAACV,cAAc,CAACmB,SAAf,CAAyBD,MAAM,CAACE,GAAhC,EAAqCF,MAArC,CAAD,CAAR;AACD,GAT6D,CAW9D;;;AACA,QAAMG,cAAc,GAAGhB,SAAS,CAACiB,WAAV,CAAsBX,QAAQ,EAA9B,CAAvB;AACA,QAAMY,MAAM,GAAGlB,SAAS,CAACmB,gBAAV,CAA2Bb,QAAQ,EAAnC,CAAf;AACA,QAAMc,IAAI,GAAGC,MAAM,CAACC,QAAP,CAAgBC,QAAhB,CAAyBC,MAAzB,CAAgC,CAAhC,EAAmCC,KAAnC,CAAyC,GAAzC,CAAb;AACA,QAAMC,cAAc,GAAGN,IAAI,CAAC,CAAD,CAAJ,KAAY,SAAZ,GAAwBA,IAAI,CAAC,CAAD,CAA5B,eAAkCF,MAAM,CAAC,CAAD,CAAxC,6CAAkC,SAAWH,GAApE;;AAEA,MAAI,CAACC,cAAD,IAAmBE,MAAM,CAACS,MAAP,KAAkB,CAAzC,EAA4C;AAC1C,UAAMtB,QAAQ,CAACJ,YAAY,CAACyB,cAAD,CAAb,CAAd;AACD;AACF,CApBM;AAsBP;;;;;;AAKA,OAAO,MAAME,eAAe,GAAG,MAAM,OAAOvB,QAAP,EAAiBC,QAAjB,KAA8B;AACjE,QAAMO,MAAM,GAAGb,SAAS,CAAC6B,SAAV,CAAoBvB,QAAQ,EAA5B,CAAf;AACA,QAAMwB,OAAO,GAAG9B,SAAS,CAAC+B,UAAV,CAAqBzB,QAAQ,EAA7B,CAAhB;AAEA,MAAI,CAACO,MAAL,EAAa,OAJoD,CAI5C;;AACrB,MAAIA,MAAM,CAACmB,WAAP,KAAuBF,OAAO,IAAI,CAACjB,MAAM,CAACoB,aAA1C,CAAJ,EAA8D,OALG,CAKK;;AAEtE,MAAIpB,MAAJ,aAAIA,MAAJ,uBAAIA,MAAM,CAAEqB,aAAZ,EAA2B;AACzB,UAAM7B,QAAQ,CAAC8B,YAAY,EAAb,CAAd;AACD;;AACD,QAAM9B,QAAQ,CAAC+B,gBAAgB,EAAjB,CAAd;AACD,CAXM;AAaP;;;;;AAIA,OAAO,MAAMC,aAAa,GAAG,MAAM,OAAOhC,QAAP,EAAiBC,QAAjB,KAA8B;AAC/D,QAAMwB,OAAO,GAAG9B,SAAS,CAAC+B,UAAV,CAAqBzB,QAAQ,EAA7B,CAAhB;;AACA,MAAIwB,OAAJ,EAAa;AACX,UAAMzB,QAAQ,CAACiC,cAAc,CAACR,OAAD,CAAf,CAAd;AACD;AACF,CALM;AAOP;;;;;AAIA,OAAO,MAAMS,eAAe,GAAG,MAAM,OAAOlC,QAAP,EAAiBC,QAAjB,KAA8B;AACjE,QAAMO,MAAM,GAAGb,SAAS,CAAC6B,SAAV,CAAoBvB,QAAQ,EAA5B,CAAf;;AACA,MAAIO,MAAJ,EAAY;AACV,UAAMR,QAAQ,CAAC+B,gBAAgB,EAAjB,CAAd;AACD;AACF,CALM;AAOP;;;;;;AAKA,OAAO,MAAMD,YAAY,GAAG,MAAM,OAAO9B,QAAP,EAAiBC,QAAjB,KAA8B;AAC9D,QAAMkC,QAAQ,GAAGxC,SAAS,CAACiB,WAAV,CAAsBX,QAAQ,EAA9B,CAAjB;;AAEA,MAAI;AACF,UAAMmC,QAAQ,GAAG,MAAMhD,GAAG,CAACsC,UAAJ,CAAeS,QAAf,CAAvB;AAEA,UAAMnC,QAAQ,CAACiC,cAAc,CAACG,QAAQ,CAAC,CAAD,CAAT,CAAf,CAAd;AACApC,IAAAA,QAAQ,CAACV,cAAc,CAAC+C,UAAf,CAA0BF,QAA1B,EAAoCC,QAAQ,CAAC,CAAD,CAA5C,CAAD,CAAR;AACApC,IAAAA,QAAQ,CAACT,UAAU,EAAX,CAAR;AACD,GAND,CAME,OAAO+C,KAAP,EAAc;AACdtC,IAAAA,QAAQ,CAACR,cAAc,CAAC,4BAAD,CAAf,CAAR;AACA+C,IAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACD;AACF,CAbM;AAeP;;;;;;;AAMA,OAAO,MAAML,cAAc,GAAIR,OAAD,IAAa,OAAOzB,QAAP,EAAiBC,QAAjB,KAA8B;AACvE,QAAMkC,QAAQ,GAAGxC,SAAS,CAACiB,WAAV,CAAsBX,QAAQ,EAA9B,CAAjB;AACA,QAAMO,MAAM,GAAGb,SAAS,CAAC6B,SAAV,CAAoBvB,QAAQ,EAA5B,CAAf;AACA,QAAMuC,MAAM,GAAG7C,SAAS,CAAC8C,SAAV,CAAoBxC,QAAQ,EAA5B,CAAf;;AAEA,MAAI;AACF,UAAMyC,SAAS,GAAG,MAAMtD,GAAG,CAACuD,YAAJ,CAAiBlB,OAAO,CAACf,GAAzB,CAAxB;AACA,UAAMkC,KAAK,GAAG,MAAMxD,GAAG,CAACyD,QAAJ,CAAapB,OAAO,CAACf,GAArB,CAApB;AACAV,IAAAA,QAAQ,CAACV,cAAc,CAACwD,QAAf,CAAwBX,QAAxB,EAAkCS,KAAlC,CAAD,CAAR;;AAEA,QAAIF,SAAJ,EAAe;AACb1C,MAAAA,QAAQ,CAACV,cAAc,CAACyD,YAAf,CAA4BZ,QAA5B,EAAsCO,SAAtC,CAAD,CAAR;AACA,UAAIM,cAAJ;;AACA,UAAIC,2BAA2B,CAACzC,MAAD,CAA/B,EAAyC;AACvC;AACAwC,QAAAA,cAAc,GAAGE,oBAAoB,CAACR,SAAD,EAAYF,MAAZ,CAArC;AACD,OAHD,MAGO;AAAA;;AACL;AACA;AACAQ,QAAAA,cAAc,GACZG,kBAAkB,CAACT,SAAD,EAAYF,MAAZ,CAAlB,KACC,MAAMpD,GAAG,CAACgE,aAAJ,CAAkBjB,QAAlB,CADP,CADF,CAHK,CAOL;;AACA,cAAMkB,UAAU,4BAAGL,cAAc,CAACM,KAAlB,0DAAG,sBACfjD,MADe,CACPkD,IAAD,IAAUA,IAAI,CAACC,MADP,EAEhBC,GAFgB,EAAnB,CARK,CAYL;;AACA,YAAIJ,UAAU,IAAI,CAACA,UAAU,CAACK,QAA9B,EAAwC;AACtC1D,UAAAA,QAAQ,CAACP,WAAW,CAACI,UAAU,CAAC8D,UAAZ,CAAZ,CAAR;AACD;AACF;;AACD3D,MAAAA,QAAQ,CAACV,cAAc,CAACsE,iBAAf,CAAiCzB,QAAjC,EAA2Ca,cAA3C,CAAD,CAAR;AACD;AACF,GA9BD,CA8BE,OAAOV,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACD;AACF,CAtCM;AAwCP;;;;;;AAKA,OAAO,MAAMP,gBAAgB,GAAG,MAAM,OAAO/B,QAAP,EAAiBC,QAAjB,KAA8B;AAClE,QAAMkC,QAAQ,GAAGxC,SAAS,CAACiB,WAAV,CAAsBX,QAAQ,EAA9B,CAAjB;AACA,QAAMuC,MAAM,GAAG7C,SAAS,CAAC8C,SAAV,CAAoBxC,QAAQ,EAA5B,CAAf;;AAEA,MAAI;AACF,UAAM0B,WAAW,GAAG,MAAMvC,GAAG,CAACyE,cAAJ,CAAmB1B,QAAnB,CAA1B;AACA,UAAM2B,WAAW,GAAGnE,SAAS,CAACoE,cAAV,CAAyB9D,QAAQ,EAAjC,CAApB,CAFE,CAIF;;AACA,QAAI,CAAA6D,WAAW,SAAX,IAAAA,WAAW,WAAX,YAAAA,WAAW,CAAExC,MAAb,MAAwB,CAA5B,EAA+B;AAC7BjC,MAAAA,IAAI,CAAC2E,4BAAL,CAAkCrC,WAAlC,EAA+CmC,WAA/C;AACD;;AACD9D,IAAAA,QAAQ,CAACV,cAAc,CAAC2E,cAAf,CAA8B9B,QAA9B,EAAwCR,WAAxC,CAAD,CAAR;AAEA,UAAMuC,gBAAgB,GAAGC,eAAe,CAACxC,WAAD,EAAca,MAAd,CAAxC;AACA0B,IAAAA,gBAAgB,IACdlE,QAAQ,CAACV,cAAc,CAAC8E,mBAAf,CAAmCjC,QAAnC,EAA6C+B,gBAA7C,CAAD,CADV;AAED,GAbD,CAaE,OAAO5B,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACD;AACF,CApBM;AAsBP;;;;;;;;AAOA,MAAMa,kBAAkB,GAAG,CAACT,SAAD,EAAYF,MAAZ,KAAuB;AAChD,OAAK,MAAMlC,IAAX,IAAmBoC,SAAnB,EAA8B;AAAA;;AAC5B,QAAI,CAAApC,IAAI,SAAJ,IAAAA,IAAI,WAAJ,8BAAAA,IAAI,CAAE+D,QAAN,kEAAgBC,OAAhB,MAA4B9B,MAAhC,EAAwC;AACtC,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD,CAPD;AASA;;;;;;;;;AAOA,MAAMU,oBAAoB,GAAG,CAACR,SAAD,EAAYF,MAAZ,KAAuB;AAClD;AACA,QAAM+B,iBAAiB,GAAG7B,SAAS,CAACrC,MAAV,CAAkBC,IAAD,IAAUA,IAAI,CAACkD,MAAhC,CAA1B;;AAEA,OAAK,MAAMa,QAAX,IAAuBE,iBAAvB,EAA0C;AACxC,SAAK,MAAMhB,IAAX,IAAmBc,QAAQ,CAACf,KAA5B,EAAmC;AACjC,UAAIC,IAAI,CAACiB,SAAL,CAAeC,EAAf,KAAsBjC,MAA1B,EAAkC;AAChC,eAAO6B,QAAP;AACD;AACF;AACF;AACF,CAXD;AAaA;;;;;;;;;AAOA,MAAMF,eAAe,GAAG,CAACxC,WAAD,EAAca,MAAd,KAAyB;AAC/C,QAAMkC,iBAAiB,GAAG/C,WAAW,CAACtB,MAAZ,CACvBsE,UAAD,IAAgBA,UAAU,CAACpE,QAAX,KAAwB,KADhB,CAA1B;;AAIA,OAAK,MAAMoE,UAAX,IAAyBD,iBAAzB,EAA4C;AAC1C,SAAK,MAAME,WAAX,IAA0BD,UAAU,CAACE,YAArC,EAAmD;AACjD,UAAID,WAAW,CAACA,WAAZ,KAA4BpC,MAA5B,IAAsCoC,WAAW,CAACpB,MAAZ,KAAuB,IAAjE,EAAuE;AACrE,eAAOmB,UAAP;AACD;AACF;AACF;AACF,CAZD;AAcA;;;;;;;AAKA,OAAO,MAAM1B,2BAA2B,GAAIzC,MAAD,IAAY;AACrD,SAAOA,MAAM,CAACsE,IAAP,KAAgB,IAAhB,IAAwBhF,WAAW,OAAO,YAAjD;AACD,CAFM","sourcesContent":["import API from \"../../../api/API\";\nimport util from \"../../../util\";\nimport * as actionCreators from \"./actionCreators\";\nimport {\n  clearError,\n  setServerError,\n  setModalKey,\n} from \"../../status/actionCreators\";\nimport { setSortedCourses } from \"../../sorted-courses/actionCreators\";\n\nimport selectors from \"../../selectors\";\nimport { changeCourse } from \"../../current-course/actionCreators\";\nimport { modalTypes } from \"../../../components/modals/redux/modalTypes\";\nimport { getUserType } from \"../../../api/tokenService\";\n/**\n * @function fetchCourses\n * Fetch the information for all courses in the given array\n * @returns {function} Redux thunk action\n */\nexport const fetchCourses = () => async (dispatch, getState) => {\n  const courses = await API.getCourses();\n\n  dispatch(setSortedCourses(courses));\n\n  const activeCourses = courses.filter((item) => item.archived !== true);\n\n  for (const course of activeCourses) {\n    dispatch(actionCreators.setCourse(course._id, course));\n  }\n\n  // Set the selected course to the first one in sorted courses or from the url\n  const selectedCourse = selectors.getCourseID(getState());\n  const sorted = selectors.getSortedCourses(getState());\n  const path = window.location.pathname.substr(1).split(\"/\");\n  const redirectCourse = path[0] === \"courses\" ? path[1] : sorted[0]?._id;\n\n  if (!selectedCourse && sorted.length !== 0) {\n    await dispatch(changeCourse(redirectCourse));\n  }\n};\n\n/**\n * @function fetchFullCourse\n * Fetch the full information for the currently selected course\n * @returns {function} Redux thunk action\n */\nexport const fetchFullCourse = () => async (dispatch, getState) => {\n  const course = selectors.getCourse(getState());\n  const session = selectors.getSession(getState());\n\n  if (!course) return; // don't load if there is no active course\n  if (course.discussions && (session || !course.ActiveSession)) return; // used cached values if they exist\n\n  if (course?.activeSession) {\n    await dispatch(fetchSession());\n  }\n  await dispatch(fetchDiscussions());\n};\n\n/**\n * Used for polling. Refreshes questions array into redux\n * @returns Redux thunk action\n */\nexport const pollQuestions = () => async (dispatch, getState) => {\n  const session = selectors.getSession(getState());\n  if (session) {\n    await dispatch(fetchQuestions(session));\n  }\n};\n\n/**\n * Used for polling. Refreshes discussions array into redux\n * @returns Redux thunk action\n */\nexport const pollDiscussions = () => async (dispatch, getState) => {\n  const course = selectors.getCourse(getState());\n  if (course) {\n    await dispatch(fetchDiscussions());\n  }\n};\n\n/**\n * @function fetchSession\n * Fetch the active session for the given course if there is one\n * @returns {function} Redux thunk action\n */\nexport const fetchSession = () => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n\n  try {\n    const sessions = await API.getSession(courseID);\n\n    await dispatch(fetchQuestions(sessions[0]));\n    dispatch(actionCreators.setSession(courseID, sessions[0]));\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setServerError(\"loading the active session\"));\n    console.error(error);\n  }\n};\n\n/**\n * @function fetchQuestions\n * Fetch the questions for an active session\n * @param {Object} session\n * @returns {function} Redux thunk action\n */\nexport const fetchQuestions = (session) => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  const course = selectors.getCourse(getState());\n  const userID = selectors.getUserID(getState());\n\n  try {\n    const questions = await API.getQuestions(session._id);\n    const stats = await API.getStats(session._id);\n    dispatch(actionCreators.setStats(courseID, stats));\n\n    if (questions) {\n      dispatch(actionCreators.setQuestions(courseID, questions));\n      let activeQuestion;\n      if (userIsAssistantOrInstructor(course)) {\n        // Check if user is helping any student\n        activeQuestion = getMyHelpingQuestion(questions, userID);\n      } else {\n        // User is a student in this course\n        // Get full attribute question from DB if it exists\n        activeQuestion =\n          studentHasQuestion(questions, userID) &&\n          (await API.getMyQuestion(courseID));\n\n        //get the most recent active help\n        const activeHelp = activeQuestion.helps\n          ?.filter((help) => help.active)\n          .pop();\n\n        // show a modal if the student has an assistant on their question\n        if (activeHelp && !activeHelp.joinedAt) {\n          dispatch(setModalKey(modalTypes.HELP_READY));\n        }\n      }\n      dispatch(actionCreators.setActiveQuestion(courseID, activeQuestion));\n    }\n  } catch (error) {\n    console.error(error);\n  }\n};\n\n/**\n * Fetch the discussions for a given course as well as the user's active discussion\n * @param {*} courseID\n * @returns {function} Redux thunk action\n */\nexport const fetchDiscussions = () => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  const userID = selectors.getUserID(getState());\n\n  try {\n    const discussions = await API.getDiscussions(courseID);\n    const description = selectors.getDescription(getState());\n\n    // Sort by description of user's Woto or question\n    if (description?.length !== 0) {\n      util.sortDiscussionsByDescription(discussions, description);\n    }\n    dispatch(actionCreators.setDiscussions(courseID, discussions));\n\n    const activeDiscussion = getMyDiscussion(discussions, userID);\n    activeDiscussion &&\n      dispatch(actionCreators.setActiveDiscussion(courseID, activeDiscussion));\n  } catch (error) {\n    console.error(error);\n  }\n};\n\n/**\n * @function studentHasQuestion\n * Determine whether or not user has an active question\n * @param {Array} questions\n * @param {String} userID\n * @returns {Boolean} whether or not signed in user has a question\n */\nconst studentHasQuestion = (questions, userID) => {\n  for (const item of questions) {\n    if (item?.question?.student === userID) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @function getMyHelpingQuestion\n * Determine whether or not user is in any questions\n * @param {Array} questions\n * @param {String} userID\n * @returns {Object} the question user is helping\n */\nconst getMyHelpingQuestion = (questions, userID) => {\n  // filter out inactive questions\n  const filteredQuestions = questions.filter((item) => item.active);\n\n  for (const question of filteredQuestions) {\n    for (const help of question.helps) {\n      if (help.assistant.id === userID) {\n        return question;\n      }\n    }\n  }\n};\n\n/**\n * @function getMyDiscussion\n * Determine whether or not user is in any active discussions\n * @param {Array} discussions\n * @param {String} userID\n * @returns {Object} the question user is helping\n */\nconst getMyDiscussion = (discussions, userID) => {\n  const activeDiscussions = discussions.filter(\n    (discussion) => discussion.archived === false\n  );\n\n  for (const discussion of activeDiscussions) {\n    for (const participant of discussion.participants) {\n      if (participant.participant === userID && participant.active === true) {\n        return discussion;\n      }\n    }\n  }\n};\n\n/**\n * @function userIsAssistantOrInstructor\n * @param {Object} course\n * @returns whether or not user is TA or instructor in the course\n */\nexport const userIsAssistantOrInstructor = (course) => {\n  return course.role === \"TA\" || getUserType() === \"instructor\";\n};\n"]},"metadata":{},"sourceType":"module"}