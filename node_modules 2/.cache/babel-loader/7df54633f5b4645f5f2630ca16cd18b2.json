{"ast":null,"code":"import API from \"../../../api/API\";\nimport { fetchSession, fetchDiscussions, fetchCourses } from \"./fetches\";\nimport selectors from \"../../selectors\";\nimport { startPageLoading, stopPageLoading, startLoading, stopLoading, clearError, setServerError, clearModalKey, blockModal, setError, setCustomServerError } from \"../../status/actionCreators\";\nimport { setActiveQuestion } from \"./actionCreators\";\n/**\n * Loads all courses into cache\n * @param {[]} courseIDs\n * @param {*} userID\n */\n\nexport const loadCourses = () => async dispatch => {\n  dispatch(startPageLoading());\n  await dispatch(fetchCourses());\n  dispatch(stopPageLoading());\n};\n/**\n * Join the queue in a session\n */\n\nexport const joinQueue = () => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  dispatch(startLoading());\n\n  try {\n    await API.postQuestion(courseID); // fetch session (instead of just dispatching the new activeQuestion) to update stats as well\n\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Leave the queue in a session\n */\n\nexport const leaveQueue = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    // Get question to set as inactive if user is in a session's queue\n    const activeQuestion = selectors.getActiveQuestion(getState());\n    const courseID = selectors.getCourseID(getState()); // Set the question as inactive\n\n    if (activeQuestion) {\n      await API.closeQuestion(activeQuestion._id); // Clear active question\n\n      dispatch(setActiveQuestion(courseID, null));\n      dispatch(clearError());\n    }\n  } catch (error) {\n    dispatch(setServerError(\"leaving the help queue\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Submit a question for an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} questionID\n * @param {*} questionDescription\n */\n\nexport const submitQuestion = questionDescription => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    const activeQuestion = selectors.getActiveQuestion(getState());\n    await API.patchQuestion(activeQuestion._id, {\n      description: questionDescription\n    });\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    console.log(\"hello\");\n    dispatch(setServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n/**\n * Edit submissison, works for both questions and discussions\n * @param {*} courseID\n * @param {*} userID\n * @param {*} description\n */\n\nexport const editSubmission = description => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    var _activeDiscussion$own;\n\n    // Edit the question\n    const activeQuestion = selectors.getActiveQuestion(getState());\n    const activeDiscussion = selectors.getActiveDiscussion(getState());\n    const userID = selectors.getUserID(getState());\n\n    if (activeQuestion) {\n      await API.patchQuestion(activeQuestion._id, {\n        description\n      });\n      await dispatch(fetchSession());\n    } // Check if it's also a discussion description\n\n\n    if (activeDiscussion && ((_activeDiscussion$own = activeDiscussion.owner) === null || _activeDiscussion$own === void 0 ? void 0 : _activeDiscussion$own._id) === userID) {\n      await API.editDiscussion(activeDiscussion._id, {\n        description\n      });\n      await dispatch(fetchDiscussions());\n    }\n\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(\"editing your question\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\nexport const joinTAVideoLink = () => async (dispatch, getState) => {\n  const activeQuestion = selectors.getActiveQuestion(getState());\n  const courseID = selectors.getCourseID(getState());\n  dispatch(clearModalKey());\n  dispatch(startLoading());\n\n  try {\n    // Create a new assistant field with student joined TODO replace with endpoint\n    const question = await API.joinTALink(activeQuestion._id);\n    console.log(question);\n    dispatch(setActiveQuestion(courseID, question));\n    dispatch(blockModal());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setCustomServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};","map":{"version":3,"sources":["/Users/jasmineharris/Desktop/Elite/woto/src/redux/courses/actions/student.js"],"names":["API","fetchSession","fetchDiscussions","fetchCourses","selectors","startPageLoading","stopPageLoading","startLoading","stopLoading","clearError","setServerError","clearModalKey","blockModal","setError","setCustomServerError","setActiveQuestion","loadCourses","dispatch","joinQueue","getState","courseID","getCourseID","postQuestion","error","console","leaveQueue","activeQuestion","getActiveQuestion","closeQuestion","_id","submitQuestion","questionDescription","patchQuestion","description","log","editSubmission","activeDiscussion","getActiveDiscussion","userID","getUserID","owner","editDiscussion","joinTAVideoLink","question","joinTALink"],"mappings":"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","sourcesContent":["import API from \"../../../api/API\";\nimport { fetchSession, fetchDiscussions, fetchCourses } from \"./fetches\";\nimport selectors from \"../../selectors\";\nimport {\n  startPageLoading,\n  stopPageLoading,\n  startLoading,\n  stopLoading,\n  clearError,\n  setServerError,\n  clearModalKey,\n  blockModal,\n  setError,\n  setCustomServerError,\n} from \"../../status/actionCreators\";\nimport { setActiveQuestion } from \"./actionCreators\";\n\n/**\n * Loads all courses into cache\n * @param {[]} courseIDs\n * @param {*} userID\n */\nexport const loadCourses = () => async (dispatch) => {\n  dispatch(startPageLoading());\n\n  await dispatch(fetchCourses());\n\n  dispatch(stopPageLoading());\n};\n\n/**\n * Join the queue in a session\n */\nexport const joinQueue = () => async (dispatch, getState) => {\n  const courseID = selectors.getCourseID(getState());\n  dispatch(startLoading());\n\n  try {\n    await API.postQuestion(courseID);\n\n    // fetch session (instead of just dispatching the new activeQuestion) to update stats as well\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Leave the queue in a session\n */\nexport const leaveQueue = () => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    // Get question to set as inactive if user is in a session's queue\n    const activeQuestion = selectors.getActiveQuestion(getState());\n    const courseID = selectors.getCourseID(getState());\n\n    // Set the question as inactive\n    if (activeQuestion) {\n      await API.closeQuestion(activeQuestion._id);\n\n      // Clear active question\n      dispatch(setActiveQuestion(courseID, null));\n      dispatch(clearError());\n    }\n  } catch (error) {\n    dispatch(setServerError(\"leaving the help queue\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Submit a question for an active session\n * @param {*} courseID\n * @param {*} userID\n * @param {*} questionID\n * @param {*} questionDescription\n */\nexport const submitQuestion = (questionDescription) => async (\n  dispatch,\n  getState\n) => {\n  dispatch(startLoading());\n\n  try {\n    const activeQuestion = selectors.getActiveQuestion(getState());\n    await API.patchQuestion(activeQuestion._id, {\n      description: questionDescription,\n    });\n\n    await dispatch(fetchSession());\n    dispatch(clearError());\n  } catch (error) {\n    console.log(\"hello\");\n    dispatch(setServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\n/**\n * Edit submissison, works for both questions and discussions\n * @param {*} courseID\n * @param {*} userID\n * @param {*} description\n */\nexport const editSubmission = (description) => async (dispatch, getState) => {\n  dispatch(startLoading());\n\n  try {\n    // Edit the question\n    const activeQuestion = selectors.getActiveQuestion(getState());\n    const activeDiscussion = selectors.getActiveDiscussion(getState());\n    const userID = selectors.getUserID(getState());\n\n    if (activeQuestion) {\n      await API.patchQuestion(activeQuestion._id, {\n        description,\n      });\n      await dispatch(fetchSession());\n    }\n    // Check if it's also a discussion description\n    if (activeDiscussion && activeDiscussion.owner?._id === userID) {\n      await API.editDiscussion(activeDiscussion._id, {\n        description,\n      });\n      await dispatch(fetchDiscussions());\n    }\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setError(\"editing your question\"));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n\nexport const joinTAVideoLink = () => async (dispatch, getState) => {\n  const activeQuestion = selectors.getActiveQuestion(getState());\n  const courseID = selectors.getCourseID(getState());\n\n  dispatch(clearModalKey());\n  dispatch(startLoading());\n\n  try {\n    // Create a new assistant field with student joined TODO replace with endpoint\n    const question = await API.joinTALink(activeQuestion._id);\n\n    console.log(question);\n    dispatch(setActiveQuestion(courseID, question));\n    dispatch(blockModal());\n    dispatch(clearError());\n  } catch (error) {\n    dispatch(setCustomServerError(error));\n    console.error(error);\n  } finally {\n    dispatch(stopLoading());\n  }\n};\n"]},"metadata":{},"sourceType":"module"}